import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<p>今天在写登录逻辑时，出现了一个错误：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Error: secretOrPrivateKey has a minimum key size of 2048 bits for RS256\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个错误通常是由于使用了长度小于 2048 位的 RSA 密钥而导致的。在使用 RS256 签名算法时，JWT 规范建议使用长度为 2048 位或更长的密钥来提供足够的安全性。</p><p>然后，就用以下命令创建了一个私钥</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl genrsa <span class="token parameter variable">-out</span> private.key <span class="token number">2048</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成私钥后，发现用于解密的公钥并没有</p><p>于是，傻乎乎地用以下命令去生成了一个公钥（注意：以下命令是错误的❌）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>openssl genrsa <span class="token parameter variable">-out</span> public.key <span class="token number">2048</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，又去走了一遍验证token的流程，发现还是返回错误。</p><hr><p>事后，我发现其实上面生成公钥的命令，其实就是生成了一个私钥，只是在输出文件时，将文件名换成了public.key而已😓</p><h2 id="解决办法" tabindex="-1"><a class="header-anchor" href="#解决办法" aria-hidden="true">#</a> 解决办法</h2><p>正确的做法应该是：</p><p>使用以下命令来生成私钥：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 用于生成长度为 2048 位的 RSA 私钥，并将其保存到名为 private.key 的文件中</span>\nopenssl genrsa <span class="token parameter variable">-out</span> public.key <span class="token number">2048</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：在私钥所在目录下，使用以下命令来生成公钥：</p><p>当然，如果非要将公钥放在另一个地方，那应该将对应的私钥所在目录的路径放入命令中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 使用 openssl rsa 命令和 -pubout 选项来从私钥中提取公钥，并将其保存到名为 public.key 的文件中</span>\nopenssl rsa <span class="token parameter variable">-in</span> private.key <span class="token parameter variable">-pubout</span> <span class="token parameter variable">-out</span> public.key\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>公钥生成后，再去走一遍验证token的流程，发现就可以走通了。</p><p>之前JWT的逻辑没少做，只是最近后端摸的少了，思路比较生了，忘了这些细的点，这才造成了这样的错误。</p><p>最近，会将后端慢慢的捡起来，成长为真正的全栈开发者~</p>', 21);
const _hoisted_22 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_22);
}
const opensslRsa_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "openssl-rsa.html.vue"]]);
export {
  opensslRsa_html as default
};
