import { _ as _export_sfc, r as resolveComponent, o as openBlock, c as createElementBlock, a as createBaseVNode, b as createTextVNode, d as createVNode, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="前瞻" tabindex="-1"><a class="header-anchor" href="#前瞻" aria-hidden="true">#</a> 前瞻</h2><p>在前面章节介绍了V8是如何通过作用域链来查找变量的，JavaScript中的对象相关内容也算是告了一段落。此篇章节将会讲述JavaScript中的类型系统，以及V8是如何实现类型转换的。</p><h2 id="v8是如何实现类型转换的" tabindex="-1"><a class="header-anchor" href="#v8是如何实现类型转换的" aria-hidden="true">#</a> V8是如何实现类型转换的？</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&quot;2&quot;</span> <span class="token operator">=</span> <span class="token operator">?</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不同于其他语言，上方表达式在JavaScript中是成立的，相加所得结果便是字符串&quot;12&quot;了。这个现象是令人疑惑的，感觉不符合人的直觉。为了解决这种疑惑，不妨可以了解下什么是JavaScript中的类型系统(Type System)？</p><p><strong>什么是类型系统（Type System）？</strong></p><p>要想理清上面的问题，需要知道类型的概念，以及JavaScript操作类型的策略了。</p><p><strong>对于机器语言而言，所有的数据都是一堆二进制代码，CPU处理这些数据的时候，并没有类型的概念，CPU所做的仅仅是移动数据，如对数据进行移位，相加或相乘。</strong></p><p><strong>对于高级语言而言，都会为操作的数据赋予指定的类型，类型可以确认一个值或者一组值具有特定的意义和目的。因此，类型是高级语言中的概念，这是机器语言所没有的</strong>。可以想象，机器语言是个冷冰冰的人，而高级语言相比之下似乎带有一点人情味。</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230301134658000.png" alt="image-20230301134658000"></p><p>在C / C++中，需要为处理的每条数据指定类型：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">666</span>\n<span class="token keyword">float</span> miles <span class="token operator">=</span> <span class="token number">6666.0</span>\n<span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">&quot;Licodeao&quot;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义变量后，C / C++编译器负责将这些数据片段转换为供CPU处理的正确命令，通常是二进制的机器代码。</p><p>在其他语言，如Python、JavaScript中，就不必为数据指定专门的数据类型了：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>counter <span class="token operator">=</span> <span class="token number">666</span>\nmiles <span class="token operator">=</span> <span class="token number">6666.0</span>\nname <span class="token operator">=</span> <span class="token string">&quot;Licodeao&quot;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">666</span>\n<span class="token keyword">let</span> miles <span class="token operator">=</span> <span class="token number">6666.0</span>\n<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">&quot;Licodeao&quot;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>尽管Python和JavaScript定义变量的方式不同，但它们都不需要直接指定变量的类型，因为虚拟机会根据数据自动推导出类型。引入这些类型之后，编译器或者解释器就可以根据类型来限制一些有害的或者没有意义的操作了</strong>。就像开头的表达式一样，对于Python而言，它觉得这个操作没有意义，而对于JavaScript来说，字符串和数字相加是有意义的，所以会得出一个结果。</p><p>每种语言都定义了自己的类型，还定义了如何操作这些类型，另外还定义了这些类型应该如何相互作用和相互约束，这就是类型系统。</p><blockquote><p>维基百科是这样解释类型系统的：</p><p><strong>在计算机科学中，类型系统（Type System）用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，如何操作这些类型，以及这些类型如何互相作用。</strong></p></blockquote><p>直观地理解，一门语言的类型系统定义了各种类型之间应该如何相互操作，如：两种不同类型相加如何处理、两种相同的类型相加又如何处理以及各种不同类型应该如何相互转换等等各种操作。因此，也可以为开头的问题解开一点眉目了，因为JavaScript的&quot;类型系统&quot;规定了两种不同类型相加是可行的，所以开发者不要觉得奇怪啦。</p>', 20);
const _hoisted_21 = {
  href: "https://262.ecma-international.org/5.1/#sec-11.6.1",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_22 = /* @__PURE__ */ createStaticVNode("<blockquote><p>AdditiveExpression : AdditiveExpression + MultiplicativeExpression</p></blockquote><ol><li><p>将第一个表达式AdditiveExpression的值赋值给左引用（lref）</p></li><li><p>使用GetValue(lref)获取左引用(lref)的计算结果，并赋值给左值(lval)</p></li><li><p>使用ReturnAbrupt(lval)获取左值，如果报错就返回错误</p></li><li><p>将第二个表达式MultiplicativeExpression的值赋值给右引用(rref)</p></li><li><p>使用GetValue(rref)获取右引用(rref)的计算结果，并赋值给右值(rval)</p></li><li><p>使用ReturnAbrupt(rval)获取右值，如果报错就返回错误</p></li><li><p>使用ToPrimitive(lval)获取左值(lval)的计算结果，并将其赋值给左原生值(lprim)</p></li><li><p>使用ToPrimitive(rval)获取右值(rval)的计算结果，并将其赋值给右原生值(rprim)</p></li><li><p>如果Type(lprim)和Type(rprim)中有一个是String类型，则：</p><p>a. 把ToString(lprim)的结果赋值给左字符串(lstr)</p><p>b. 把ToString(rprim)的结果赋值给右字符串(rstr)</p><p>c. 返回左字符串(lstr)和右字符串(rstr)拼接的字符串</p></li><li><p>把ToNumber(lprim)的结果赋值给左数字(lnum)</p></li><li><p>把ToNumber(rprim)的结果赋值给右数字(rnum)</p></li><li><p>返回左数字(lprim)和右数字(rprim)相加的数值</p></li></ol><p>显而易见的是，<strong>两种不同类型的值相加时，如果一个为String类型，那么最终的结果为一个字符串，这导致了另一个值的类型需要转为字符串类型，然后与String类型进行拼接得结果。</strong></p>", 3);
const _hoisted_25 = /* @__PURE__ */ createBaseVNode(
  "strong",
  null,
  "通俗地讲，V8会提供一个ToPrimitive方法，其作用是将a和b转换为原生数据类型",
  -1
  /* HOISTED */
);
const _hoisted_26 = {
  href: "https://www.licodeao.top/articles/Exploration%20of%20relational%20operators.html",
  target: "_blank",
  rel: "noopener noreferrer"
};
const _hoisted_27 = /* @__PURE__ */ createStaticVNode('<ul><li><strong>先检测该对象是否存在valueOf方法，如果有就返回原始类型，那么就使用该值进行强制类型转换</strong></li><li><strong>如果valueOf方法没有返回原始类型，那么就使用toString方法的返回值</strong></li><li><strong>如果valueOf方法和toString方法都不返回基本类型值，便会触发一个TypeError的错误</strong></li></ul><blockquote><p><strong>将对象转换为原生类型</strong>的流程图，如下：</p></blockquote><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230301145016740.png" alt="image-20230301145016740"></p><p>当V8执行1+&quot;2&quot;时，<strong>因为这是两个原始值相加，原始值相加时，如果其中一项是字符串，那么V8会默认将另外一个值也转换为字符串</strong>，相当于执行了以下操作：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;2&quot;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里<strong>把数字1偷偷转换为字符串&quot;1&quot;的过程也称为强制类型转换，这种转换是隐式的。</strong></p><p>再来看段代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> Obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token string">&quot;200&quot;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token number">100</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Obj <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据之前的描述，由于需要使用ToPrimitive方法将Obj转换为原生数据类型，而ToPrimitive会优先调用对象中的valueOf方法，由于valueOf方法返回100，那么Obj就会被转换为数字100，那么数字100加数字3，结果当然是103了。</p><p>假如让valueOf方法和toString方法都返回对象，结果又如何呢？</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> Obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Obj <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合之前的描述，是不是隐隐猜出会报错？</p><p>因为ToPrimitive会优先调用valueOf方法，发现返回的是一个对象，并不是原生类型，当ToPrimitive继续调用了toString方法时，发现toString方法返回的也是一个对象，都是对象，自然无法继续执行相加运算了，这时V8就会抛出一个异常：</p><blockquote><p>❌Uncaught TypeError ：Cannot convert object to primitive value</p></blockquote><p>提示的是类型错误，错误原因是无法将对象类型转换为原生类型。</p><p>因此，<strong>在执行相加操作时，V8会通过ToPrimitive方法将对象类型转换为原生类型，最后就是两个原生类型相加。如果其中一个值的类型是字符串时，则另一个值也需要强制转换为字符串，然后做字符串的拼接。在其他情况时，所有的值都会转换为数字类型，然后做数字的相加。</strong></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><strong>JavaScript有自己的&quot;类型系统&quot;，其规定了哪些操作是可行的或有意义的。</strong></li><li><strong>对于机器语言来说，是不存在类型这种概念的，而高级语言存在类型。</strong></li><li><strong>ToPrimitive方法，其作用是将a和b转换为原生数据类型。</strong></li><li><strong>将对象转换为原生类型</strong>的过程： <ul><li><strong>先检测该对象是否存在valueOf方法，如果有就返回原始类型，那么就使用该值进行强制类型转换</strong></li><li><strong>如果valueOf方法没有返回原始类型，那么就使用toString方法的返回值</strong></li><li><strong>如果valueOf方法和toString方法都不返回基本类型值，便会触发一个TypeError的错误</strong></li></ul></li><li><strong>数字1偷偷转换为字符串&quot;1&quot;的过程也称为强制类型转换，这种转换是隐式的。</strong></li></ul>', 18);
function _sfc_render(_ctx, _cache) {
  const _component_ExternalLinkIcon = resolveComponent("ExternalLinkIcon");
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createBaseVNode("p", null, [
      createTextVNode("当有两个值相加时，V8会严格根据ECMAScript规范来执行操作（ECMAScript是一个语言标准，JavaScript就是ECMAScript的一个实现），在ECMAScript中就定义了如何执行加法操作。具体可参考"),
      createBaseVNode("a", _hoisted_21, [
        createTextVNode("ECMAScript规范"),
        createVNode(_component_ExternalLinkIcon)
      ]),
      createTextVNode("，大概翻译如下：")
    ]),
    _hoisted_22,
    createBaseVNode("p", null, [
      _hoisted_25,
      createTextVNode("，其实我在另一篇博客中也提到过这个方法，"),
      createBaseVNode("a", _hoisted_26, [
        createTextVNode("详情可看这里"),
        createVNode(_component_ExternalLinkIcon)
      ]),
      createTextVNode("。转换流程如下：")
    ]),
    _hoisted_27
  ]);
}
const V8_Engine_jiu__html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "V8 Engine(jiu).html.vue"]]);
export {
  V8_Engine_jiu__html as default
};
