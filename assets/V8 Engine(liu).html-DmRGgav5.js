import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="前瞻" tabindex="-1"><a class="header-anchor" href="#前瞻" aria-hidden="true">#</a> 前瞻</h2><p>之前，分析了什么是JavaScript中的对象，以及V8内部是如何存储对象的，那么此篇将揭示V8引擎是如何实现JavaScript中的对象继承的。</p><h2 id="基于原型的继承是如何实现的" tabindex="-1"><a class="header-anchor" href="#基于原型的继承是如何实现的" aria-hidden="true">#</a> 基于原型的继承是如何实现的？</h2><p><strong>什么是继承？</strong></p><p>简单地说，<strong>继承就是一个对象可以访问另外一个对象中的属性和方法</strong>，如下图：</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/extend.png" alt=""></p><p>因为B继承了A，所以B就可以直接使用A中的name属性了，就好比儿子可以使用父亲的遗产、可以住进父亲所买的房子...</p><p>当然，<strong>不同的语言实现继承的方式是不同的</strong>，其中<strong>最典型的两种方式</strong>是</p><ul><li><strong>基于类的继承</strong></li><li><strong>基于原型的继承</strong></li></ul><p><strong>基于类的继承，提供了很多复杂的规则，以及非常多的关键字，如class、friend、protected等等，通过组合使用这些关键字，就可以实现继承的效果</strong>。可预见的是，当业务复杂时，需要维护非常复杂的继承关系，从而导致代码过于臃肿和复杂。</p><p>而在JavaScript这门语言中，实现继承的方式与其他语言有着很大差别。<strong>JavaScript本身不提供一个class实现，尽管在ES6中引入了class关键字，但这仅仅是语法糖，和基于类的继承没有任何关系</strong>。这也代表着，JavaScript并没有向传统的OOL偏移。<strong>JavaScript仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制</strong>，某种意义来说，基于原型的继承没有基于类的继承那么复杂，反而显得简短与简洁。</p><hr><p><strong>基于原型的继承到底是如何实现的？</strong></p><blockquote><p>说明：_ _ proto _ _（这里是连着的双短横线，因为typora的限制，连着的短横线会造成加粗的效果，因此只能分开短横线了）</p></blockquote><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230226235556186.png" alt="image-20230226235556186"></p><p>如上图，有一个对象C，它包含了一个type属性，毫无疑问的是，对象C可以直接访问它自己的type属性。</p><p><strong>如何让对象C像访问自己的属性一样，访问对象B呢？</strong></p><p>在前一章中，可以发现<strong>在V8的内存快照中，JavaScript的每个对象都包含了一个隐藏属性__ proto __，该隐藏属性称之为对象的原型（prototype）， _ _ proto _ _指向了内存中的另外一个对象，我们就把 _ _ proto _ _ 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象中的属性或方法了。</strong></p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230227000947899.png" alt="image-20230227000947899"></p><p>上图中，让对象C的原型（即 _ _ proto _ _ ）指向了对象B，那么依据上方的概念，对象B不就是对象C的原型对象了吗？因此，便可以利用对象C来访问对象B中的属性或方法了。</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230227001442970.png" alt="image-20230227001442970"></p><p>上图中，当对象C将它的 _ _ proto _ _ 属性指向了对象B后，通过对象C来访问对象B中的name属性时，V8会先从对象C中开始查找，没有查找到时，V8会继续在其原型对象(即对象B)中查找，因为对象B中包含了name属性，所以V8就直接返回对象B中的name属性值了。</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230227002241892.png" alt="image-20230227002241892"></p><p>观察上图，对象A有个属性是color，那么通过对象C去访问对象A中的color属性时，V8会先在对象C中查找，没有查找到时，接着继续在对象C的原型对象B中查找，依然没有查找到时，会继续去对象B的原型对象A中查找，因为对象A包含了color属性，所以V8就返回了该属性值。<strong>这种查找属性的路径称为原型链，它像一个链条一样，将几个原型链接了起来。</strong></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><strong>继承就是一个对象可以访问另外一个对象中的属性和方法</strong></li><li><strong>实现继承的方式最典型的两种方式</strong><ul><li><strong>基于类的继承</strong></li><li><strong>基于原型的继承</strong></li></ul></li><li><strong>JavaScript仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制</strong></li><li><strong>JavaScript的每个对象都包含了一个隐藏属性__ proto __，该隐藏属性称之为对象的原型（prototype）</strong></li><li><strong>_ _ proto _ _指向了内存中的另外一个对象，我们就把 _ _ proto _ _ 指向的对象称为该对象的原型对象</strong></li></ul><p>关于V8引擎是如何实现JavaScript中的对象继承的，还没说完，继续看下一章...</p>', 27);
const _hoisted_28 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_28);
}
const V8_Engine_liu__html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "V8 Engine(liu).html.vue"]]);
export {
  V8_Engine_liu__html as default
};
