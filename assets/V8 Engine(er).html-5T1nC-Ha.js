import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="前瞻" tabindex="-1"><a class="header-anchor" href="#前瞻" aria-hidden="true">#</a> 前瞻</h2><p>上一篇文章讲到，<strong>JavaScript代码需要转换为机器代码，CPU才能识别并运行</strong></p><p>那么为什么需要对JavaScript代码进行编译以及编译后是如何运行的?</p><h2 id="高级代码为什么需要先编译再执行" tabindex="-1"><a class="header-anchor" href="#高级代码为什么需要先编译再执行" aria-hidden="true">#</a> 高级代码为什么需要先编译再执行</h2><blockquote><p><strong>一切高级编程语言都需要和CPU进行交流</strong></p><p>那么CPU是如何执行机器代码的?</p></blockquote><p>为了完成复杂的任务，工程师们<strong>为CPU提供了一大堆指令</strong>，来实现各种功能，这<strong>一大堆指令成为指令集(Instructions)，也就叫做机器语言</strong></p><p><strong>注意，CPU只能识别二进制的指令</strong></p><p>对于程序员来说，二进制指令集难以记忆，因此<strong>又将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令集</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1000100111011000 - 机器指令\nmov ax,bx - 汇编指令\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，<strong>CPU不能识别汇编语言</strong>，需要经过下图的转换</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220924133438441.png" alt="image-20220924133438441"></p><p>CPU不只是只有一种架构，如果要使用机器代码或者汇编代码来实现一个功能，那么需要为每种架构的CPU编写特定的汇编代码。其次，在编写汇编代码时，还需要了解和处理器架构相关的硬件知识。显然，这太过繁琐了，因此需要一种来屏蔽计算机架构细节的语言，随之，高级编程语言应运而生。</p><p><strong>和汇编语言一样，处理器也不能直接识别由高级语言所编写的代码</strong>，通常有两种方式来执行这些代码</p><ul><li><p><strong>解释执行</strong></p><ul><li><p>需要<strong>先将输入的源代码通过解析器编译成中间代码</strong>，之后<strong>直接使用解释器解释中间代码，随即得到结果</strong></p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220924134649199.png" alt="image-20220924134649199"></p></li></ul></li><li><p><strong>编译执行</strong></p><ul><li><p>需要<strong>先将输入的源代码转换成中间代码</strong>，之后<strong>编译器再将中间代码编译成机器代码。</strong></p></li><li><p>通常<strong>编译成的机器代码是以二进制文件形式存储的</strong>，需要执行这段程序的时候直接执行二进制文件就可以了。还可以<strong>使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。</strong></p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220924135407477.png" alt="image-20220924135407477"></p></li></ul></li></ul><p>以上，就是<strong>计算机执行高级语言的两种基本方式：解释执行、编译执行</strong></p><h2 id="v8怎么执行javascript代码的" tabindex="-1"><a class="header-anchor" href="#v8怎么执行javascript代码的" aria-hidden="true">#</a> V8怎么执行JavaScript代码的</h2><blockquote><p>V8作为JavaScript虚拟机的一种，它是如何执行JavaScript代码的呢？</p></blockquote><p>实际上，<strong>V8并没有采用某种单一的技术</strong>，而是<strong>混合解释执行和编译执行</strong>这两种执行方式。<strong>这种把解释器和编译器混合使用的方式称之为JIT(Just In Time) - 即时编译技术。</strong></p><blockquote><p>那么，V8为什么会采用这种方式呢？</p></blockquote><p>这不得不说，解释执行和编译执行各自的优点和缺点了。</p><p><strong>解释执行</strong></p><ul><li>启动速度快</li><li>执行速度慢</li></ul><p><strong>编译执行</strong></p><ul><li>启动速度慢</li><li>执行速度快</li></ul><p>如此，这就保证了V8引擎的高性能。</p><h2 id="跟踪一段代码的运行" tabindex="-1"><a class="header-anchor" href="#跟踪一段代码的运行" aria-hidden="true">#</a> 跟踪一段代码的运行</h2><blockquote><p>这一行代码交给V8引擎后产生的结果是怎么样的呢？</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// test.js</span>\n<span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token string">&quot;licodeao&quot;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>首先，这行代码<strong>会被解析器结构化为AST</strong></p><p>使用d8指令(d8 --print-ast test.js)来看看会输出啥</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[generating bytecode for function: ]\n--- AST ---\nFUNC at 0\n. KIND 0\n. LITERAL ID 0\n. SUSPEND COUNT 0\n. NAME &quot;&quot;\n. INFERRED NAME &quot;&quot;\n. DECLS\n. . VARIABLE (000001EAC5CE43E8) (mode = VAR, assigned = true) &quot;test&quot;\n. BLOCK NOCOMPLETIONS at -1\n. . EXPRESSION STATEMENT at 192\n. . . INIT at 192\n. . . . VAR PROXY unallocated (000001EAC5CE43E8) (mode = VAR, assigned = true) &quot;test&quot;\n. . . . LITERAL &quot;licodeao&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面就是转换后的AST，可以将其转换为一个图形树方便观察</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220924141723862.png" alt="image-20220924141723823"></p><blockquote><p>在<strong>生成AST的同时，还会生成作用域</strong></p><p>使用d8指令(d8 --print-scopes test.js)来看看作用域是啥样的</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Global scope:\nglobal { // (000002A331BC4198) (0, 202)\n  // will be compiled\n  // 1 stack slots\n  // temporary vars:\n  TEMPORARY .result;  // (000002A331BC4518) local[0]\n  // local vars:\n  VAR test;  // (000002A331BC43E8) \n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以明显地看到，test变量被添加到了全局作用域中</p><blockquote><p>生成了AST和作用域后，就可以<strong>使用解释器(ignition)生成字节码</strong>了</p><p>使用d8指令(d8 --print-bytecode test.js)来看看生成的字节码</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[generated bytecode for function:  (0x03530824fa29 &lt;SharedFunctionInfo&gt;)]\nParameter count 1\nRegister count 3\nFrame size 24\n         000003530824FA9A @    0 : 12 00             LdaConstant [0]     \n         000003530824FA9C @    2 : 26 fa             Star r1\n         000003530824FA9E @    4 : 27 fe f9          Mov &lt;closure&gt;, r2\n         000003530824FAA1 @    7 : 61 37 01 fa 02    CallRuntime [DeclareGlobals], r1-r2\n         000003530824FAA6 @   12 : 12 01             LdaConstant [1]\n         000003530824FAA8 @   14 : 15 02 00          StaGlobal [2], [0]\n         000003530824FAAB @   17 : 0d                LdaUndefined\n         000003530824FAAC @   18 : aa                Return\nConstant pool (size = 3)\n000003530824FA65: [FixedArray] in OldSpace\n - map: 0x0353080404b1 &lt;Map&gt;\n - length: 3\n           0: 0x03530824fa51 &lt;FixedArray[1]&gt;\n           1: 0x03530824f9f1 &lt;String[#8]: licodeao&gt;\n           2: 0x0353081c851d &lt;String[#4]: test&gt;\nHandler Table (size = 0)\nSource Position Table (size = 0)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>生成字节码后，解释器就会解释执行这段字节码，<strong>如果重复执行了某段代码，监控器就会将其标注为hot函数，并提交给编译器进行优化执行</strong></p><p>使用d8指令(d8 --trace-opt test.js)查看哪些代码被优化了</p></blockquote><blockquote><p>如果要查看哪些代码被反优化了</p><p>使用d8指令(d8 --trace-deopt test.js)查看哪些代码被反优化了</p><p>显然，由于测试代码过于简单，并没有触发V8的优化机制，所以就不演示了。</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>时隔这么久，也是很惭愧了。希望以后能坚持在周末输出专栏文章吧~</p><ul><li>由于计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种方式 <ul><li>解释执行 <ul><li>启动速度快</li><li>执行速度慢</li></ul></li><li>编译执行 <ul><li>启动速度慢</li><li>执行速度快</li></ul></li></ul></li><li>V8采用<strong>JIT（即时编译）技术</strong>来执行JavaScript代码，这是一种权衡策略，即<strong>在启动过程中采用了解释执行的策略，如果某段代码的执行频率超过了一个值，那么V8就会采用优化编译器将其编译成执行效率更加高效的机器代码。</strong></li></ul>', 42);
const _hoisted_43 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_43);
}
const V8_Engine_er__html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "V8 Engine(er).html.vue"]]);
export {
  V8_Engine_er__html as default
};
