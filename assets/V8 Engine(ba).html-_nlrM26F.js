import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="前瞻" tabindex="-1"><a class="header-anchor" href="#前瞻" aria-hidden="true">#</a> 前瞻</h2><p>在前面章节介绍了JavaScript的继承是基于原型链的，原型链将一个个对象串起来，从而实现对象属性的查找，这篇将会讲述V8是如何通过作用域链来查找变量的。</p><h2 id="v8如何通过作用域链来查找变量" tabindex="-1"><a class="header-anchor" href="#v8如何通过作用域链来查找变量" aria-hidden="true">#</a> V8如何通过作用域链来查找变量？</h2><p>原型链是将一个个对象串起来，同样的，<strong>作用域链就是将一个个作用域串起来，实现变量查找的路径。</strong></p><p>需要知道的是<strong>作用域就是存放变量和函数的地方</strong>，全局下有全局作用域，全局作用域中存放全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。当在函数内部使用一个变量时，V8便会去作用域中查找，通过代码来看一下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;licodeao&quot;</span>\n<span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span>\n\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span>\n  <span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">&quot;function&quot;</span>\n  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面代码中，我们在全局环境中声明了变量name和type，同时还定义了bar函数和foo函数，在bar函数中又再次定义了变量name和type，在foo函数中再次定义了变量name。函数的调用关系是：在全局环境中调用bar函数，在bar函数中调用foo函数，在foo函数中打印出变量name和type的值。</p><p>当执行到foo函数时，首先需要打印出变量name的值，但我们在三个地方都定义了变量name，那么究竟应该使用哪个变量呢？</p><p>在foo函数中使用了变量name，那么V8就应该先使用foo函数内部定义的变量name，这符合正常的直觉，最终的结果也确实如此。</p><p>随后，foo函数继续打印变量type，但是在foo函数内部并没有定义变量type，而是在全局环境中和bar函数中分别定义了变量type，那么这时foo函数打印出的变量type是bar函数中的，还是全局环境中的呢？</p><p>先卖个关子，我们先来了解下<strong>什么是函数作用域和全局作用域？</strong></p><blockquote><p><strong>作用域的工作原理</strong>：</p><p><strong>每个函数在执行时都需要查找自己的作用域，称之为函数作用域，在执行阶段，执行一个函数时，当该函数需要使用某个变量或者调用了某个函数时，便会优先在该函数作用域内查找相关内容。</strong></p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> test<span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">test_scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">;</span>\n  test <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test_scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上方代码中，我们定义了一个test_scope函数，那么在V8执行test_scope函数时，在编译阶段会为test_scope函数创建一个作用域，在test_scope函数中定义的变量和声明的函数都会丢到该作用域中，另外，V8还会默认将隐藏变量this存放到作用域中。</p><p>在test_scope函数中使用了变量x，但是在test_scope函数的作用域中，并没有定义变量x，那么V8应该如何去获取变量x呢？显然的是，如果在当前函数作用域中没有查找到变量，那么V8会去全局作用域中查找，这个查找的路径就称为作用域链。</p><p><strong>全局作用域和函数作用域类似，也是存放变量和函数的地方，但是对于V8而言，它们还是有一点不一样：</strong></p><ul><li><strong>全局作用域是在V8启动过程中就创建了，且一直保存在内存中不会被销毁，直至V8退出。</strong></li><li><strong>函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之销毁掉了。</strong></li></ul><p>不仅仅是销毁时机不同，全局作用域中包含了很多全局变量，如果是浏览器，全局作用域中还有window、document等非常多的对象和方法，如果是node环境，那么会有Global、File等对象，当然，无论什么环境下，都会有全局的this值。</p><p><strong>V8启动后就会进入正常的消息循环状态，这时就可以执行代码了</strong>，如上方代码，V8就会先解析顶层（Top Level）代码，显而易见的是，在顶层代码中定义了变量x，这时V8就会将变量x添加到全局作用域中了。</p><p><strong>作用域链是如何工作的？</strong></p><p>回到开头的问题，来看看作用域链究竟是如何运作的。</p><p>首先，<strong>当V8启动时，会进入正常的消息循环状态，执行相应的代码，并且会创建全局作用域</strong>，全局作用域中包括了this、window、document等变量。<strong>V8会先编译顶层代码，在编译过程中会将顶层定义的变量和声明的函数都添加到全局作用域中</strong>，如下图：</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230228233534120.png" alt="image-20230228233534120"></p><p>（注意图中并不是一一对应的关系，只是为了好看排整齐而已...）</p><p>全局作用域创建完成后，V8便进入了执行状态，在前面章节说过变量提升，（当然这里提一嘴：var定义的变量才会有变量提升，而let和const定义的变量不会有），因为变量提升的原因，可以将之前的代码分解为以下部分：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">===</span><span class="token operator">===</span> 解析阶段 <span class="token operator">-</span><span class="token operator">&gt;</span> 实现变量提升 <span class="token operator">===</span><span class="token operator">===</span>\n<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token keyword">undefined</span>\n<span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token keyword">undefined</span>\n\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span>\n  <span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token string">&quot;function&quot;</span>\n  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token operator">===</span><span class="token operator">===</span> 执行阶段 <span class="token operator">===</span><span class="token operator">===</span>\nname <span class="token operator">=</span> <span class="token string">&quot;licodeao&quot;</span>\ntype <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span>\n<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一部分是在编译阶段完成的，此时全局作用域中两个变量的值依然是undefined，然后进入执行阶段；第二部分就是执行时的顺序，首先全局作用域中的两个变量分别赋值&quot;licodeao&quot;和&quot;global&quot;，然后就开始执行函数bar的调用了。</p><p>当<strong>V8执行函数bar</strong>时，<strong>同样需要经历两个阶段：编译和执行</strong>。在编译阶段，V8会为bar函数创建函数作用域，如下图：</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230228235101732.png" alt="image-20230228235101732"></p><p>然后进入了bar函数的执行阶段，在bar函数中，只是简单地调用了foo函数，因此V8又开始执行foo函数了。</p><p>同样地，在编译foo函数的过程中，V8会为foo函数创建函数作用域，如下图：</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230228235440750.png" alt="image-20230228235440750"></p><p>最终，我们得到了三个作用域了，分别是全局作用域，bar函数的函数作用域以及foo函数的函数作用域。</p><p>将开头的问题转换为作用域链的问题，foo函数查找变量的路径到底是怎样的？</p><ul><li>foo函数作用域 -&gt; bar函数作用域 -&gt; 全局作用域</li><li>foo函数作用域 -&gt; 全局作用域</li></ul><blockquote><p><strong>词法作用域是指，查找作用域的顺序是按照函数定义时的位置来决定的。</strong></p><p><strong>由于作用域是在声明函数时就已经确定好了，所以也可以将词法作用域称为静态作用域。</strong></p><p><strong>和静态作用域相对的是动态作用域，其并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，在动态作用域中，作用域链是基于调用栈的，而不是基于函数定义的位置的。</strong></p></blockquote><p>因为JavaScript是基于词法作用域的，bar和foo函数的外部代码都是全局代码，所以无论是在bar函数中查找变量，还是在foo函数中查找变量，其查找顺序都是按照当前函数作用域 -&gt; 全局作用域这个路径来的。</p><p>至此，我们就能够解决开头的问题了。由于代码中的foo函数和bar函数都是在全局下面定义的，所以在foo函数中使用了type，最终打印出来的值就是全局作用域中的type。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><strong>作用域链就是将一个个作用域串起来，实现变量查找的路径。</strong></li><li><strong>作用域的工作原理</strong>：<strong>每个函数在执行时都需要查找自己的作用域，称之为函数作用域，在执行阶段，执行一个函数时，当该函数需要使用某个变量或者调用了某个函数时，便会优先在该函数作用域内查找相关内容。</strong></li><li><strong>词法作用域是指，查找作用域的顺序是按照函数定义时的位置来决定的。</strong></li></ul>', 40);
const _hoisted_41 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_41);
}
const V8_Engine_ba__html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "V8 Engine(ba).html.vue"]]);
export {
  V8_Engine_ba__html as default
};
