import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h2><p>在 Rust 中，每一个值都是一个数据类型。这告诉了 Rust 它被指定为何种数据，以便更好地明确数据处理方式。</p><p>数据类型有两个子集：标量（scalar）和复合（compound）</p><h3 id="标量类型" tabindex="-1"><a class="header-anchor" href="#标量类型" aria-hidden="true">#</a> 标量类型</h3><p>标量类型代表一个单独的值，在 Rust 中，有 4 种基本的标量类型：</p><ul><li>整型</li><li>浮点型</li><li>布尔型</li><li>字符类型</li></ul><h4 id="整型" tabindex="-1"><a class="header-anchor" href="#整型" aria-hidden="true">#</a> 整型</h4><p>数字类型默认为 <code>i32</code>。</p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>每一个变体都是有符号或无符号的，并且一定有值。</p><p>有符号位的变体可以存储 <code>-(2^(n - 1))</code> 到 <code>2^(n - 1) - 1</code> 的数字，无符号位的变体可以存储 <code>0</code> 到 <code>2^n - 1</code> 的数字。</p><p><code>isize</code> 和 <code>usize</code> 类型是依赖于运行程序的计算机架构，比如 64 位架构上它们就是 64 位的，32 位架构上它们就是 32 位的。</p><p>多种数字类型的数字字面值允许使用类型后缀，如 <code>66i8</code>。</p><blockquote><p>整型溢出</p></blockquote><p>Rust 也会出现整型溢出的问题</p><ul><li>当在 <code>debug</code> 模式下编译代码时，会出现整型溢出的 <code>panic</code></li><li>而在 <code>release</code> 模式下编译代码时，不会出现整型溢出的 <code>panic</code> ，在这种模式下 Rust 会进行一种 <code>二进制补码</code> 的操作，即比此类型能容纳的最大值还大的值会绕回到最小值，如最大值为 <code>256</code>，此时值被绑定为 <code>266</code>，那么此时这个值会变为 <code>0</code>，以此类推。这种方式就能够解释了为什么 Rust 在 <code>release</code> 模式下编译代码时不会出现整型溢出的 <code>panic</code> 了。但是随之而来的问题是，变量可能也不会得到你期望的值了。</li><li>显式地解决整型溢出的错误的办法，可以使用以下几种标准库提供的原始数字类型方法： <ul><li><code>wrapping_*</code> 方法</li><li><code>checked_*</code> 方法</li><li><code>overflowing_*</code> 方法</li><li><code>saturating_*</code> 方法</li></ul></li></ul><h4 id="浮点型" tabindex="-1"><a class="header-anchor" href="#浮点型" aria-hidden="true">#</a> 浮点型</h4><p>浮点型默认为 <code>f64</code>。所有的浮点型都是有符号的。</p><p>Rust 中有两个浮点数类型：<code>f32</code> 和 <code>f64</code>。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">64.0</span><span class="token punctuation">;</span> <span class="token comment">// f64</span>\n  <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token keyword">f32</span> <span class="token operator">=</span> <span class="token number">32.0</span><span class="token punctuation">;</span> <span class="token comment">// f32</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="布尔型" tabindex="-1"><a class="header-anchor" href="#布尔型" aria-hidden="true">#</a> 布尔型</h4><p>Rust 中有两个布尔型：<code>true</code> 和 <code>false</code>，使用 <code>bool</code> 表示类型。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> f<span class="token punctuation">:</span> <span class="token keyword">bool</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="字符类型" tabindex="-1"><a class="header-anchor" href="#字符类型" aria-hidden="true">#</a> 字符类型</h4><p>使用 <code>char</code> 表示字符类型</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token char">&#39;z&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> <span class="token keyword">str</span><span class="token punctuation">:</span> <span class="token keyword">char</span> <span class="token operator">=</span> <span class="token lifetime-annotation symbol">&#39;char</span>&#39;<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>⚠️：使用单引号声明 <code>char</code> 字面量，双引号声明的是字符串字面量。</p><h3 id="复合类型" tabindex="-1"><a class="header-anchor" href="#复合类型" aria-hidden="true">#</a> 复合类型</h3><p>复合类型是将多个值组合成一个类型，Rust 有两个原生类型：数组、元组。</p><h4 id="元组" tabindex="-1"><a class="header-anchor" href="#元组" aria-hidden="true">#</a> 元组</h4><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。</p><p>元组的长度一旦固定，其长度不会增大或缩小，和其他语言一样。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> tuple<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">32.1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从元组中获取单个值，可以使用模式匹配来解构元组。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">32.1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  \n  <span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">=</span> tuple<span class="token punctuation">;</span>\n  \n  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The value of x is: {x}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用 <code>.</code> 加 值的索引方式来获取单个值。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">32.1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  \n  <span class="token keyword">let</span> x <span class="token operator">=</span> tuple<span class="token number">.0</span><span class="token punctuation">;</span>\n  \n  <span class="token keyword">let</span> y <span class="token operator">=</span> tuple<span class="token number">.1</span><span class="token punctuation">;</span>\n  \n  <span class="token keyword">let</span> z <span class="token operator">=</span> tuple<span class="token number">.2</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不带任何值的元组，被称为单元元组，值和对应的类型都写为 <code>()</code>。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> tuple<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h4><p>与其他语言一样，数组类型也是要求数组中元素的类型保持一致。有点不同的是，Rust 中的数组长度是固定的，也就是说长度不可变。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">,</span> <span class="token number">333</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要在栈空间上分配空间或固定保有元素的数量时，数组非常适合。但数组没有 <code>vector</code> 类型灵活。</p><p><code>vector</code> 类型是标准库提供的一个允许增长或减少长度的类似于数组的集合类型。</p><p>可以这样写数组类型，方括号包含每个元素的类型，后跟数组元素的数量。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你也可以在方括号中指定初始值并再加元素个数来创建一个每个元素都为相同值的数组：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 [3, 3, 3, 3, 3]</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <code>panic</code> 。</p><p>这种错误处理机制使程序既不会 <code>panic</code> 也不会导致非法内存访问。</p>', 50);
const _hoisted_51 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_51);
}
const rustDataType_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "rust-data-type.html.vue"]]);
export {
  rustDataType_html as default
};
