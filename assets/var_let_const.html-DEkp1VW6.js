import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="体验了一下let和const-真香" tabindex="-1"><a class="header-anchor" href="#体验了一下let和const-真香" aria-hidden="true">#</a> 体验了一下let和const，真香</h2><p>为啥香啊？在我看来，写代码过程中，当用var定义了多个变量时，有时难免出现变量名重复而你根本没发现，然后抓头发，头发抓着抓着就没了🤣如果没有某些方面的改善，let和const也许就不会出现了。</p><hr><h2 id="先来说说let和const两兄弟" tabindex="-1"><a class="header-anchor" href="#先来说说let和const两兄弟" aria-hidden="true">#</a> 先来说说let和const两兄弟</h2><p>这俩的出现绝非偶然，就像你人生中遇到的人一样。</p><p>let用来声明变量，而const用来声明常量（即不变的值，源自单词constant）。显然地，let代替了var用来声明变量，而<strong>const则是新出现的专门用来声明常量的，与var没有任何关系！</strong>（有些练习题就喜欢这样下套！）。虽然一个用来代替，一个是新出现的，但两个的用法与var是一样的。</p><hr><h2 id="列一下变量与常量的区别吧" tabindex="-1"><a class="header-anchor" href="#列一下变量与常量的区别吧" aria-hidden="true">#</a> 列一下变量与常量的区别吧</h2><p><strong>变量：可对其重新赋值。</strong></p><p><strong>常量：一旦初始化，就不能对其重新赋值。</strong></p><hr><h2 id="let没啥好说的-说说const" tabindex="-1"><a class="header-anchor" href="#let没啥好说的-说说const" aria-hidden="true">#</a> let没啥好说的，说说<code>const</code></h2><p>新出现的关键字，其注意事项有：</p><p>1.使用<code>const</code>声明常量时，一旦声明，就必须立即赋值初始化，不能留到以后赋值。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> a<span class="token punctuation">;</span>\na <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你这样写，恭喜你，浏览器控制台给你留了一句话：<strong>&quot;Missing initializer in <code>const</code> declaration&quot;</strong>。因此，使用<code>const</code>进行声明常量时，千万别忘了给它赋值。</p><p>2.使用<code>const</code>声明的常量，允许在不重新赋值的情况下修改它的值。</p><p>啊？这是什么意思？</p><p>其实有两层意思，重点是&quot;<strong>不重新赋值</strong>&quot;。1.当const声明一个<strong>基本数据类型</strong>时，如：<code>const</code> sex = &#39;male&#39;; 你如何在不重新为sex常量赋值的情况下改变sex常量的值？有啥办法呢？答案是：<strong>没有任何办法</strong>。那你说的这种情况是指啥？说的就是：2.当const声明一个<strong>引用数据类型</strong>时，如（对象）：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n       <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;Alex&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token comment">// 以下哪种修改是对的?</span>\n<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 重新赋值了<span class="token punctuation">,</span>且空对象在转为Boolean类型时会隐式转换为<span class="token boolean">true</span>\nperson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;ZhangSan&#39;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两句谁修改的是对的？当然是第二句啰。第一句明显就是给常量对象person赋值了一个空对象，犯了大忌。我们不能给常量对象赋值，难道还不能修改其属性的值啊？显然是可以的。</p><hr><h2 id="什么时候用let-什么时候用const" tabindex="-1"><a class="header-anchor" href="#什么时候用let-什么时候用const" aria-hidden="true">#</a> 什么时候用let，什么时候用const?</h2><p>首先，当清楚自己的需求或者你一眼就能看出是用let还是const（比如循环）;当你不清楚需求的情况下，推荐先用const声明，因为在以后需要改变常量的值时，你能看得到错误，不至于用let可能发现不了。</p><hr><h2 id="重头戏来啦-开始讲故事了" tabindex="-1"><a class="header-anchor" href="#重头戏来啦-开始讲故事了" aria-hidden="true">#</a> 重头戏来啦，开始讲故事了</h2><p>我觉得这绝壁是八股文中的一个：<strong>let、const、var的区别</strong>。区别是什么？有多少个区别？</p><p>有5个区别：</p><ol><li><strong>重复声明</strong></li><li><strong>变量提升</strong></li><li><strong>暂时性死区</strong></li><li><strong>window对象的属性和方法</strong></li><li><strong>块级作用域</strong></li></ol><h2 id="啥叫重复声明啊" tabindex="-1"><a class="header-anchor" href="#啥叫重复声明啊" aria-hidden="true">#</a> 啥叫重复声明啊？</h2><p>重复声明是指：<strong>已经存在的变量或常量，又声明了一遍</strong>。var存在重复声明，而let和const不存在。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token operator">...</span><span class="token operator">...</span>\n<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的输出i为2，再来看let和const。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token operator">...</span><span class="token operator">...</span>\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用let声明时，会出现报错，显示a已经声明过了。</p><p>那再来看看这个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用函数func时，会出现啥结果呢？仍然是报错，显示a已经声明过了。为啥啊？</p><p>因为含义中说的&quot;<strong>已经存在</strong>&quot;是指&lt;<strong>以任何形式存在</strong>的变量或常量&gt;，那么函数的形参也算是变量啊，因此会报错。所以在理解重复声明时，<strong>要特别注意这个&quot;已经存在&quot;指的是以任何形式存在的变量或常量</strong>。</p><hr><h2 id="啥叫变量提升呢" tabindex="-1"><a class="header-anchor" href="#啥叫变量提升呢" aria-hidden="true">#</a> 啥叫变量提升呢？</h2><p>其含义是：<strong>var会将变量的声明提升到当前作用域的顶部。<strong>因此</strong>var存在变量提升，而let和const不存在</strong>，上栗子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个会报错吗？还是会输出a的值呀？都不是，这段代码相当于下面的代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\na <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看完这两个栗子再加上含义理解理解。咱来说说：</p><p>正如下面代码所示，其背后的形式长这样。在上面的代码中，程序开始按顺序执行，console语句执行时，发现程序要它去输出a的值，可console愁呀！前面都没看到a的影子啊，更别提上哪儿去找a的值了。诶，且慢，这时，在它下面的var看到了console的愁容，说：哥们儿，我有超能力啊，我可以让a去你的前面，但这超能力有限，不能让a把它的值也带上。console无语了，想了想这也是个办法，总比让浏览器大哥报错的好啊。于是，var就照办了，谁来都不好使。因此，console只能输出一个未带值的a，于是浏览器无情地告诉咱们：undefined。那咱们就明白了呗，<strong>var会将声明的变量提升到当前作用域的顶部</strong>，那这个栗子中的作用域是啥？当然是全局作用域啊，难道这里还有啥作用域吗？</p><p>变量提升，咱就讲完了。</p><hr><h2 id="啥叫暂时性死区啊" tabindex="-1"><a class="header-anchor" href="#啥叫暂时性死区啊" aria-hidden="true">#</a> 啥叫暂时性死区啊？</h2><p>别急，咱先说说其含义：<strong>只要作用域中存在let、const，它们所声明的变量或常量就会自动&quot;绑定&quot;这个区域，不会再受到外部作用域的影响</strong>。因此，let和const存在暂时性死区，而var不存在。</p><p>啊？这是啥？ 那咱看看下面的栗子呗：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n     <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>别急别急，咱先来捋一捋程序咋样执行的：**值得注意的是：只有当函数被调用时，才会生成函数作用域，函数调用结束后，其生成的函数作用域也随之而消亡。**有了这个前提，咱们再来说说：程序执行时，会先略过声明，而是直接执行函数调用（这又是重要的一点：<strong>程序执行时会先略过声明！</strong>），func函数被调用了，那么它生成了一个函数作用域，在这个函数中，接着执行console语句，诶，你说巧不巧，程序又让console去找a的值，那它咋办嘛，只能是现在当前的函数作用域中找有没有a呀，很可惜，它没找到。这里可能又有人说了：啊？下面不是有a吗？记住：<strong>查找是从内部作用域——&gt;外部作用域——&gt;直到全局作用域</strong>。因此console没找到a，console苦啊，内部的函数作用域中，它没找到a，在家里竟然都没找到。于是它又只能爬山涉水地往外部作用域走了，但此时！它发现它走不出去了！家里门被锁了！为什么呀？因为它看不到它的家里其实还有一个let声明的变量a！这个let很坏，当它出现在别人家里并声明了一个变量时，它就会把别人家的门给锁了！console麻了呀，到死都出不去，又只能向浏览器报告说自己根本找不到a，浏览器直呼离谱，于是直接向我们报错：a未初始化。也就是说，<strong>当一个作用域中出现了let、const，且它们也声明了一个变量，那么这个变量就会自动”绑定“当前作用域，使其不受外部作用域的影响</strong>。</p><p>我们能否先将视线看向变量提升和暂时性死区的代码？能发现什么吗？这些代码的顺序是不是不太正常啊？没错，反观这些栗子以及变量提升和暂时性死区的含义，我们不难得出：这两个名词的出现，不就是提醒我们要养成良好的编程习惯吗？</p><hr><h2 id="咱们轻松地聊聊关于window对象的属性和方法" tabindex="-1"><a class="header-anchor" href="#咱们轻松地聊聊关于window对象的属性和方法" aria-hidden="true">#</a> 咱们轻松地聊聊关于window对象的属性和方法</h2><p>这个完全是对于var来说的。</p><p>其含义为：在<strong>全局作用域</strong>中，<strong>var声明的变量，通过function关键字声明的函数，会自动地变成window对象的属性和方法</strong>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>add <span class="token operator">===</span> add<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会输出 18 和 true。</p><p>而当let和const声明时</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>add <span class="token operator">===</span> add<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会输出 undefined 和 false。</p><p>这个没啥好讲的，记住就行。</p><hr><h2 id="啥叫块级作用域-怎么又有一个块级作用域啊" tabindex="-1"><a class="header-anchor" href="#啥叫块级作用域-怎么又有一个块级作用域啊" aria-hidden="true">#</a> 啥叫块级作用域？怎么又有一个块级作用域啊？</h2><p>var不存在块级作用域，而let和const存在块级作用域。</p><p>先来个栗子看看：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n   <span class="token operator">...</span><span class="token operator">...</span>\n<span class="token punctuation">}</span>\n console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哈？我就猜到你会说这是个块级作用域。其实，这里没有啥块级作用域，只存在一个全局作用域。那么此时var声明的就是一个全局变量啦，最终输出为3。</p><p>再来看一个栗子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token operator">...</span><span class="token operator">...</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>诶？那这次输出的会不会是3呢？很遗憾，也不是。此时<strong>let与for循环组成了一个块级作用域</strong>。那么，在循环之外的console语句想输出i的值，却找不到，就告诉浏览器没找到，于是浏览器告诉我们：i没有被定义。</p><p>谈谈<strong>作用域链</strong>：</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/屏幕截图-2021-10-11-005020-1024x520.png" alt=""></p><p>由于自己写然后再画作用域时直线不直太丑了，就找了张图。</p><p>正如图中所看到的，for循环与let形成了块级作用域，函数被调用之后形成了函数作用域，而全局作用域本身就存在。其实，这顺序在上边中也提到过，查找变量时，是沿着作用域链往外寻找的，也即顺序为：<strong>内部作用域——&gt;外部作用域——&gt;......——&gt;直到全局作用域</strong>。沿着这个顺序查找就行。</p><hr><h2 id="那有哪些块级作用域呢" tabindex="-1"><a class="header-anchor" href="#那有哪些块级作用域呢" aria-hidden="true">#</a> 那有哪些块级作用域呢？</h2><p>大部分{ } 、if(){ }、while(){ }、do{ }while()、for( ){}、switch(){ }，这些花括号+let/const = 块级作用域。</p><p>尽管function(){ }也有花括号，但它属于函数作用域。</p><p>尽管对象也有{}，但它不构成任何作用域！</p><p>对了，<strong>作用域有三个：全局作用域、函数作用域、块级作用域。</strong></p>', 84);
const _hoisted_85 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_85);
}
const var_let_const_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "var_let_const.html.vue"]]);
export {
  var_let_const_html as default
};
