import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="前瞻" tabindex="-1"><a class="header-anchor" href="#前瞻" aria-hidden="true">#</a> 前瞻</h2><p>在前面的章节中，了解了V8引擎中的对象和函数，以及&quot;函数是一等公民&quot;的概念。</p><p>细分函数，又有函数声明和函数表达式，可先看之前的文章《关于JavaScript函数引用的理解》</p><p>那么，V8引擎是如何处理函数声明和函数表达式的？</p><h2 id="函数声明与函数表达式的差异" tabindex="-1"><a class="header-anchor" href="#函数声明与函数表达式的差异" aria-hidden="true">#</a> 函数声明与函数表达式的差异</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 函数声明</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;函数声明 - foo&quot;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 函数表达式</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;函数表达式 - foo&quot;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以猜想一下上方的代码的运行结果。</p><p>显然，第一段代码可以正常运行，而第二段代码会报错，同样是在定义的函数之前调用函数，为什么会出现这种差异呢？</p><p>主要因为<strong>这两种定义函数的方式在编译器看来具有不同语义</strong>，进而触发了不同的行为。</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20221030215111344.png" alt="image-20221030215111344"></p><p><strong>因为语义的不同，所以第一种称为函数声明，第二种称为函数表达式</strong>。</p><h2 id="v8引擎是怎么处理函数声明的" tabindex="-1"><a class="header-anchor" href="#v8引擎是怎么处理函数声明的" aria-hidden="true">#</a> V8引擎是怎么处理函数声明的？</h2><p>V8引擎在执行JavaScript的过程中，会<strong>先对其进行编译，然后再执行</strong>，如下面这段代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>大致执行过程</p></blockquote><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20221030221347205.png" alt="image-20221030221347205"></p><p>其实执行细节，前面的章节都有提到过，这里再回顾一遍。</p><blockquote><p>细节</p></blockquote><ol><li><p>在<strong>编译阶段</strong>：</p><p>​ 如果<strong>解析到函数声明</strong>，那么<strong>V8引擎会将这个函数声明转换为内存中的函数对象</strong>，<strong>并将其放到作用域中</strong>。同样，<strong>如果解析到某个变量声明，也会将其放到作用域中，但是会将其值初始化会undefined，表示该变量还未被使用</strong>。</p></li><li><p>在<strong>执行阶段</strong>：</p><p>​ <strong>如果使用了某个变量，或者调用了某个函数，那么V8引擎便会去作用域查找相关内容</strong>。</p></li><li><p><strong>上方代码的作用域</strong>：</p></li></ol><blockquote><p>d8调试工具测试</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Inner <span class="token keyword">function</span> <span class="token function-variable function">scope</span><span class="token operator">:</span>\n<span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (000002101BDC2470) (361, 390)  </span>\n  <span class="token comment">// 2 heap slots</span>\n<span class="token punctuation">}</span>\nGlobal scope<span class="token operator">:</span>\nglobal <span class="token punctuation">{</span> <span class="token comment">// (000002101BDC2168) (0, 390)</span>\n  <span class="token comment">// will be compiled</span>\n  <span class="token comment">// 1 stack slots</span>\n  <span class="token comment">// temporary vars:</span>\n  <span class="token constant">TEMPORARY</span> <span class="token punctuation">.</span>result<span class="token punctuation">;</span>  <span class="token comment">// (000002101BDC2718) local[0]</span>\n  <span class="token comment">// local vars:</span>\n  <span class="token constant">VAR</span> x<span class="token punctuation">;</span>  <span class="token comment">// (000002101BDC23B8)</span>\n  <span class="token constant">VAR</span> foo<span class="token punctuation">;</span>  <span class="token comment">// (000002101BDC2670)</span>\n\n  <span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (000002101BDC2470) (361, 390)</span>\n    <span class="token comment">// lazily parsed</span>\n    <span class="token comment">// 2 heap slots</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 可以看到，<strong>作用域中包含了变量x和foo，且变量x的默认值是undefined，变量foo指向了foo函数对象，foo函数对象被V8引擎存放在内存中的堆空间了</strong>。因此，<strong>可以得出，这些变量都是在编译阶段被装进作用域的</strong>。</p><p>​ 因为在执行之前，这些变量都被提升到了作用域中了，因此在执行阶段，V8引擎理所当然地就能获取到所有的变量了，<strong>这种在编译阶段，将所有的变量提升到了作用域的过程</strong>称为<strong>变量提升</strong>。</p><p>​ 回到最开始的问题，为什么会出现差异？这是因为<strong>函数声明在编译阶段就被提升到了作用域中，在执行阶段，只要是在作用域中存在的变量或者对象，都是可以被使用的</strong>。通过上面的分析，知道了<strong>如果是一个普通变量，变量提升之后的值都是undefined，如果是声明的函数，那么变量提升之后的值则是函数对象</strong>。</p><blockquote><h4 id="为什么函数声明经过变量提升后-其值会是函数对象" tabindex="-1"><a class="header-anchor" href="#为什么函数声明经过变量提升后-其值会是函数对象" aria-hidden="true">#</a> <strong>为什么函数声明经过变量提升后，其值会是函数对象？</strong></h4></blockquote><p>是因为<strong>表达式</strong>和<strong>语句</strong>的区别。</p><blockquote><p>那么什么是表达式，什么又是语句呢？</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>x <span class="token operator">=</span> <span class="token number">3</span>\n<span class="token number">3</span> <span class="token operator">===</span> <span class="token number">4</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上都是表达式，<strong>因为它们都会返回一个值</strong>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> x\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上就是语句了，<strong>执行该语句时，V8引擎并不会返回任何值给你</strong>。</p><p>同样，<strong>函数声明也是一个语句</strong>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当执行这段代码时，<strong>V8引擎并不会返回任何的值，它只会在编译阶段解析foo函数，并将函数对象存储到内存中</strong>。</p><blockquote><p>语句亦可以操作表达式</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 语句操作表达式</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 表达式</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>知道了表达式和语句的区别，接着探索。</p><p>V8引擎在执行上方 var x = 3 这段代码时，会认为它是两段代码</p><ul><li>一段是<strong>定义变量的语句</strong>：var x = undefined</li><li>一段是<strong>赋值的表达式</strong>：x = 3</li></ul><p>​ 首先，<strong>在变量提升阶段，V8引擎并不会执行赋值的表达式，该阶段只会解析基础的语句，如变量的定义、函数的声明</strong>。因此，这两行代码是在不同的阶段完成的，<strong>var x 是在编译阶段完成的，也可以说是变量提升阶段，而 x = 3 是表达式，所有的表达式是在执行阶段完成的</strong>。<strong>在变量提升阶段(即编译阶段)，V8引擎将这些变量存放在作用域时，还会将其值初始化为undefined</strong>。综上所述，<strong>表达式是不会在编译阶段执行的</strong>。<strong>函数是一个对象，所以在编译阶段，V8引擎就会将整个函数对象提升到作用域中，并不是给该函数名称赋一个undefined</strong>。</p><blockquote><p>小结</p></blockquote><ul><li>如果遇到<strong>普通的变量声明，那么便会将其提升到作用域中，并将其值初始化为undefined</strong></li><li>如果遇到的是<strong>函数声明，那么V8引擎会在内存中为函数声明生成一个函数对象，并将该对象提升到作用域中</strong></li></ul><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20221030232741304.png" alt="image-20221030232741304"></p><h2 id="v8引擎是怎么处理函数表达式的" tabindex="-1"><a class="header-anchor" href="#v8引擎是怎么处理函数表达式的" aria-hidden="true">#</a> V8引擎是怎么处理函数表达式的？</h2><blockquote><p>函数表达式与函数声明的最主要区别</p></blockquote><ul><li>函数表达式是在<strong>表达式语句中</strong>使用function的</li><li>在函数表达式中，<strong>可以省略函数名称，从而创建匿名函数</strong></li><li><strong>一个函数表达式可以被用作一个即时调用的函数表达式——IIFE（Immediately Invoked Function Expression）</strong></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上方代码时，<strong>V8引擎会先查找声明语句</strong>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 拆分成以下代码</span>\n<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">undefined</span>\n<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行是声明语句，V8引擎在解析阶段，就会在作用域中创建该对象，并将该对象设置为undefined</p><p>第二行是函数表达式，<strong>在编译阶段，V8引擎并不会处理函数表达式</strong>，所以也就不会将该函数表达式提升到作用域中了</p><p>因此，在函数表达式之前调用该函数foo，此时foo只是指向了undefined，所以就相当于调用一个undefined，而undefined并不是函数，于是就报错了。</p><h3 id="立即调用的函数表达式-iife" tabindex="-1"><a class="header-anchor" href="#立即调用的函数表达式-iife" aria-hidden="true">#</a> 立即调用的函数表达式（IIFE）</h3><p>上面我们清楚了，在编译阶段，V8引擎是不会处理函数表达式的。</p><blockquote><p>JavaScript中有一个<strong>圆括号运算符</strong>，<strong>圆括号里可以放一个表达式</strong></p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 在小括号里放入一段函数的定义</span>\n<span class="token punctuation">(</span><span class="token function">funciton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n	<span class="token comment">// some statements </span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 立即调用函数表达式（IIFE）</span>\n<span class="token punctuation">(</span><span class="token function">funciton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n	<span class="token comment">// some statements </span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为<strong>小括号之间存放的必须是表达式</strong>，所以<strong>如果在小括号里定义一个函数，那么V8引擎就会把这个函数看成是函数表达式，执行时它会返回一个函数对象</strong>。倘若，<strong>在表达式后面加上调用的括号，就称为立即调用函数表达式（IIFE）</strong></p><p>因为<strong>函数表达式也是表达式，所以V8在编译阶段，并不会为该表达式创建函数对象</strong>。这样的<strong>好处是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到（或称为隔离）</strong></p><p>另外，<strong>因为立即调用的函数表达式是立即执行的</strong>，<strong>所以将一个立即调用的函数表达式赋给一个变量时，不是存储IIFE本身，而是存储IIFE执行后返回的结果</strong>，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> l <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><strong>函数声明的本质是语句</strong>，而<strong>函数表达式的本质是表达式</strong></li><li>如果<strong>提升一个变量，那么V8引擎在将变量提升到作用域时，会将其值初始化为undefined</strong>，如果是<strong>函数声明，那么V8引擎会在内存中创建该函数对象，并提升到整个函数对象到作用域中</strong></li><li><strong>在编译阶段，V8引擎并不会将函数表达式中的函数对象提升到全局作用域中，因此无法在函数表达式之前使用该函数</strong></li><li><strong>IIFE是一种特别的表达式，可以起到变量隔离和代码隐藏的作用</strong></li></ul>', 62);
const _hoisted_63 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_63);
}
const V8_Engine_wu__html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "V8 Engine(wu).html.vue"]]);
export {
  V8_Engine_wu__html as default
};
