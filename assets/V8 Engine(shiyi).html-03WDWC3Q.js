import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="前瞻" tabindex="-1"><a class="header-anchor" href="#前瞻" aria-hidden="true">#</a> 前瞻</h2><p>在前一章我们介绍了V8的基础环境，当中提到了堆空间和栈空间。栈空间是一块连续的栈结构空间，被调用的函数会依次放入栈空间中，但由于V8对栈空间大小进行了限制，于是又有了堆空间。堆空间是个树形结构，可以存储很多数据，因此被常用来存放对象类型的数据。在JavaScript中，函数也是对象，因此函数可以被放入堆空间中。那么既然被调用的函数既可以放入栈空间中，又可以放入堆空间中，不管栈空间还是堆空间都会消耗一定的内存，因此是不是可以提出&quot;函数调用是如何影响到内存的&quot;这个问题呢？</p><h2 id="函数调用是如何影响内存的" tabindex="-1"><a class="header-anchor" href="#函数调用是如何影响内存的" aria-hidden="true">#</a> 函数调用是如何影响内存的？</h2><p>在使用JavaScript中，经常会遇到栈溢出的错误，如下面的代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很显然，V8就会报告栈溢出的错误，为了解决栈溢出的问题，可以在foo函数内部使用setTimeout来触发foo函数的调用。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样改造后，就可以正确地执行了。</p><p>如果使用Promise来代替setTimeout，在Promise的then方法中调用foo函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器中执行这段代码，并没有报告栈溢出的错误，因为页面已经卡死了。</p><p>那么为什么上面三段代码，会出现不同的结果呢？</p><p>主要原因是因为这三段代码的底层执行逻辑是完全不同的：</p><ul><li>第一段代码是在同一个任务中重复调用嵌套的foo函数</li><li>第二段代码是使用setTimeout让foo函数在不同的任务中执行</li><li>第三段代码是在同一个任务中执行foo函数，但是并不是嵌套执行</li></ul><p>V8在执行这三种不同代码时，它们的内存布局是不同的，而不同的内存布局又会影响到代码的执行逻辑，因此我们来看看JavaScript执行时的内存布局吧！</p><p><strong>为什么使用栈结构来管理函数调用？</strong></p><p>大部分高级语言都会采用栈这种数据结构来管理函数调用，为什么？这与函数的特性有关，通常函数有两个主要的特性：</p><ul><li>函数可以被调用。可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制权将从父函数转移到子函数，子函数执行结束之后，又会将代码执行控制权返还给父函数。</li><li>函数具有作用域机制。所谓作用域机制，是指函数在执行时可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量也成为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁了。</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">getZ</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token function">getZ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然上方代码中包含了多层函数嵌套调用，但过程其实很简单，以下是函数调用示意图：</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230303225123732.png" alt="image-20230303225123732"></p><p>观察流程图，是否可以看出：函数调用者的生命周期总是长于被调用者，并且被调用者的生命周期总是先于调用者的生命周期结束。我们知道，被调用的函数会被放入到调用栈中，那么&quot;函数调用者的生命周期总是长于被调用者&quot;这句话是不是就是（后进）的意思？&quot;被调用者的生命周期总是先于调用者的生命周期结束&quot;这句话是不是就是（先出）的意思？因为是栈结构嘛，栈的特点不就是先进后出、后进先出吗？</p><blockquote><p>注：可能上面先进后出有点抽象，但把视角放到&quot;被调用者&quot;就好理解了。是被调用者后进先出，这样就符合生命周期的说法了。</p></blockquote><p>因为函数是有作用域机制的，作用域机制通常表现在函数执行时，会在内存中分配函数内部的变量、上下文等数据，在函数执行完成之后，这些存储的内部数据就会被销毁掉。所以站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数，而函数资源的释放则总是先于调用函数。</p><p>不论从生命周期的角度，还是函数的资源分配的角度，都能发现它们符合&quot;后进先出&quot;的策略，而栈结构正好满足这种后进先出的需求，所以选择栈来管理函数调用关系是一种很自然的选择。</p><p><strong>栈如何管理函数调用？</strong></p><blockquote><p>当执行一个函数的时候，栈怎么变化？</p></blockquote><p>当一个函数被执行时，函数的参数、函数内部定义的变量都会依次压入到栈中。</p><p>函数在执行过程中，其内部的临时变量会按照执行顺序被压入到栈中。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">int</span> x <span class="token operator">=</span> num1<span class="token punctuation">;</span>\n  <span class="token keyword">int</span> y <span class="token operator">=</span> num2<span class="token punctuation">;</span>\n  <span class="token keyword">int</span> ret <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>\n  x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>\n  <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> z<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230303234724481.png" alt="image-20230303234724481"></p><p>当add函数执行完成之后，需要将执行代码的控制权转交给main函数，意味着需要将栈的状态恢复到main函数上次执行时的状态，这个过程叫做恢复现场。如何恢复到main函数的执行现场呢？</p><p>只要在寄存器中保存一个永远指向当前栈顶的指针，栈顶指针的作用就是告诉你应该往哪个位置添加新元素，这个指针通常存放在esp寄存器中。如果想往栈中添加一个元素，那么需要先根据esp寄存器找到当前栈顶的位置，然后在栈顶上方添加新元素，新元素添加后，还需要将新元素的地址更新到esp寄存器中。</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230304001719671.png" alt="image-20230304001719671"></p><p>将esp的指针向下移动到之前main函数执行时的地方就可以了，不过CPU是如何知道要移动到这个地址的呢？</p><p>解决办法是增加了另外一个ebp寄存器，用来保存当前函数的起始位置，一个函数的起始位置也成为栈帧指针，ebp寄存器中保存的就是当前函数的栈帧指针。</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230304001953448.png" alt="image-20230304001953448"></p><p>在main函数调用add函数时，main函数的栈顶指针就变了add函数的栈帧指针了，所以需要将main函数的栈顶指针保存到ebp中，当add函数执行结束后，需要销毁add函数的栈帧，并恢复main函数的栈帧。因为main函数也有它自己的栈帧指针，所以在执行main函数之前，还需恢复它的栈帧指针，那么如何恢复呢？</p><p>通常是在main函数中调用add函数时，CPU会将当前main函数的栈帧指针保存在栈中，当函数调用结束之后，就需要恢复main函数的执行现场了，首先取ebp中的指针，并写入esp中，然后从栈中取出之前保留的main函数的栈帧地址，将其写入ebp中，到这里ebp和esp都恢复了，就可以继续执行main函数了。</p><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20230304003406412.png" alt="image-20230304003406412"></p><blockquote><p>什么是栈帧？</p><p>每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。</p></blockquote><p>在JavaScript中，函数的执行过程也是类似的，如果调用一个新函数，那么V8会为该函数创建栈帧，等函数执行结束之后，销毁该栈帧，并且V8限制了栈结构的大小，因此如果重复嵌套执行一个函数，那么就会导致栈溢出。</p><p>至此，再回头看看开头的三段代码：</p><ul><li>第一段代码由于循环嵌套调用了foo，所以当函数运行时，就会导致foo函数会不断地调用foo函数自身，这样会导致栈无限增，进而导致栈溢出的错误。</li><li>第二段代码是在函数内部使用了setTimeout来启动foo函数，这段代码之所以不会导致栈溢出，是因为setTimeout会使得foo函数在消息队列后面的任务中执行，并不会影响到当前的栈结构，也就不会导致栈溢出。</li><li>第三段代码是Promise，Promise涉及到了微任务，这种方式会导致主线程卡死，但不会造成栈溢出。微任务与宏任务，会在后面章节继续研究。</li></ul><p><strong>有了栈，为什么还会有堆？</strong></p><p>前面提到，栈管理函数调用，具有很多优势：</p><ul><li>栈结构的特点&quot;后进先出&quot;非常适合函数调用过程</li><li>在栈上分配资源和销毁资源的速度非常快，因为栈空间是连续的</li></ul><p>栈最大的缺点也是它的优点所造成的，那就是连续的空间要想在内存中分配一块连续的大空间是非常难的，因此导致了栈空间是有限的，正是基于栈不方便存放大的数据，因此有了另外一种数据结构用来保存一些大数据，这就是堆。</p><p>和栈空间不同，存放在堆空间的数据是不要求连续存放的，从堆上分配内存块没有固定的模式，可以在任何时候分配和释放它。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">Point</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">int</span> x<span class="token punctuation">;</span>\n  <span class="token keyword">int</span> y<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>\n  <span class="token keyword">int</span> <span class="token operator">*</span>z <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">;</span>\n  <span class="token operator">*</span>z <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n  \n  Point p<span class="token punctuation">;</span>\n  p<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>\n  p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>\n  \n  Point <span class="token operator">*</span>pp <span class="token operator">=</span> new <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  pp<span class="token operator">-&gt;</span>y <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>\n  pp<span class="token operator">-&gt;</span>x <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>\n  delete z<span class="token punctuation">;</span>\n  delete pp<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上方代码在new时，表示要在堆中分配一块空间，然后返回分配后的地址，通常返回的地址会被保存到栈中。当然，堆中的数据不再需要时，需要对其进行销毁。C、C++需要手动管理内存，没有手动销毁堆中的数据，会造成内存泄漏，Java、JavaScript使用了自动垃圾回收的策略。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>每个函数在执行过程中，都有自己的生命周期和作用域，当函数执行结束时，其作用域也会被销毁。因此会使用栈结构来管理函数的调用过程，也把管理函数调用过程的栈结构称为调用栈。</li><li>函数可以被调用。</li><li>函数具有作用域机制。</li><li>函数调用者的生命周期总是长于被调用者，并且被调用者的生命周期总是先于调用者的生命周期结束。</li><li>站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数，而函数资源的释放则总是先于调用函数。</li><li>当一个函数被执行时，函数的参数、函数内部定义的变量都会依次压入到栈中。</li><li>什么是栈帧？每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。</li><li>如果调用一个新函数，那么V8会为该函数创建栈帧，等函数执行结束之后，销毁该栈帧，并且V8限制了栈结构的大小，因此如果重复嵌套执行一个函数，那么就会导致栈溢出。</li></ul>', 53);
const _hoisted_54 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_54);
}
const V8_Engine_shiyi__html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "V8 Engine(shiyi).html.vue"]]);
export {
  V8_Engine_shiyi__html as default
};
