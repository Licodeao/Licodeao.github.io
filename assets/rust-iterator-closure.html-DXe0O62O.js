import { _ as _export_sfc, r as resolveComponent, o as openBlock, c as createElementBlock, a as createBaseVNode, b as createTextVNode, d as createVNode, e as withCtx, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createBaseVNode(
  "h2",
  {
    id: "迭代器与闭包",
    tabindex: "-1"
  },
  [
    /* @__PURE__ */ createBaseVNode("a", {
      class: "header-anchor",
      href: "#迭代器与闭包",
      "aria-hidden": "true"
    }, "#"),
    /* @__PURE__ */ createTextVNode(" 迭代器与闭包")
  ],
  -1
  /* HOISTED */
);
const _hoisted_2 = /* @__PURE__ */ createBaseVNode(
  "p",
  null,
  "在 Rust 中，也可以看到函数式编程的影子，如闭包、迭代器等等。函数式编程风格通常包含将函数作为参数值或其他函数的返回值、将函数赋值给变量以供之后执行等等。",
  -1
  /* HOISTED */
);
const _hoisted_3 = /* @__PURE__ */ createBaseVNode(
  "h3",
  {
    id: "闭包",
    tabindex: "-1"
  },
  [
    /* @__PURE__ */ createBaseVNode("a", {
      class: "header-anchor",
      href: "#闭包",
      "aria-hidden": "true"
    }, "#"),
    /* @__PURE__ */ createTextVNode(" 闭包")
  ],
  -1
  /* HOISTED */
);
const _hoisted_4 = /* @__PURE__ */ createStaticVNode('<blockquote><p>闭包捕获其环境</p></blockquote><p>闭包可以捕获定义它环境中的值以便后续使用。在 Rust 中，闭包怎么定义？通过 <code>||</code> 双杠符号来定义，这表示一个闭包。如果闭包有参数，则参数会出现在两道竖杠之间。</p><p>例如以下例子：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug, PartialEq, Copy, Clone)]</span>\n<span class="token keyword">enum</span> <span class="token type-definition class-name">Number</span> <span class="token punctuation">{</span>\n  <span class="token class-name">Zero</span><span class="token punctuation">,</span>\n  <span class="token class-name">One</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">struct</span> <span class="token type-definition class-name">Invensity</span> <span class="token punctuation">{</span>\n  shirts<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Number</span><span class="token operator">&gt;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">impl</span> <span class="token class-name">Invensity</span> <span class="token punctuation">{</span>\n  <span class="token keyword">fn</span> <span class="token function-definition function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> user_profile<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Number</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Number</span> <span class="token punctuation">{</span>\n    user_profile<span class="token punctuation">.</span><span class="token function">unwrap_or_else</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token keyword">fn</span> <span class="token function-definition function">value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Number</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> <span class="token keyword">mut</span> max_zero <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> <span class="token keyword">mut</span> max_one <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">for</span> shirt <span class="token keyword">in</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>shirts <span class="token punctuation">{</span>\n      <span class="token keyword">match</span> shirt <span class="token punctuation">{</span>\n        <span class="token class-name">Number</span><span class="token punctuation">::</span><span class="token class-name">Zero</span> <span class="token operator">=&gt;</span> max_zero <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">,</span>\n        <span class="token class-name">Number</span><span class="token punctuation">::</span><span class="token class-name">One</span> <span class="token operator">=&gt;</span> max_one <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">if</span> max_zero <span class="token operator">&gt;</span> max_one <span class="token punctuation">{</span>\n      <span class="token class-name">Number</span><span class="token punctuation">::</span><span class="token class-name">Zero</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Number</span><span class="token punctuation">::</span><span class="token class-name">One</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> invensity <span class="token operator">=</span> <span class="token class-name">Invensity</span> <span class="token punctuation">{</span>\n    shirts<span class="token punctuation">:</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token class-name">Number</span><span class="token punctuation">::</span><span class="token class-name">Zero</span><span class="token punctuation">,</span> <span class="token class-name">Number</span><span class="token punctuation">::</span><span class="token class-name">One</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  \n  <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Number</span><span class="token punctuation">::</span><span class="token class-name">Zero</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> res1 <span class="token operator">=</span> invensity<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;result: {:?}&quot;</span><span class="token punctuation">,</span> res1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>unwrap_or_else</code> 是由标准库定义在 <code>Option&lt;T&gt;</code> 上的方法，它获取一个没有参数、返回值类型为 <code>T</code> 的闭包作为参数。如果 <code>Option&lt;T&gt;</code> 是 <code>Some</code> 成员，则 <code>unwrap_or_else</code> 返回 <code>Some</code> 中的值；如果 <code>Option&lt;T&gt;</code> 是 <code>None</code> 成员，则 <code>unwrap_or_else</code> 调用闭包并返回闭包返回的值。</p><p>在上方代码中，将闭包表达式 <code>|| self.value()</code> 作为方法 <code>unwrap_or_else</code> 的参数，<code>|| self.value()</code> 这个闭包表达式本身不获取参数，如果有参数则位于两道竖杠之间，闭包体调用了 <code>self.value()</code> 。之后，<code>unwrap_or_else</code> 会在需要结果的时候调用这个闭包。在 <code>Invensity</code> 实例上调用了 <code>self.value()</code> 的闭包，闭包捕获了一个 <code>Invensity</code> 实例的不可变引用到 <code>self</code> ，函数就不能以这种方式捕获其环境。</p><blockquote><p>闭包类型推导与注解</p></blockquote><p>闭包不用像函数一样在参数和返回值上都要显式地标注类型，函数是暴露给用户的接口，闭包存储在变量中并被使用，不用命名它们或暴露给库的用户使用。</p><p>闭包通常很短，并且只关联于小范围的上下文，闭包也可以添加类型注解，以达到更强的明确性。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> expression <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>num<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>\n  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;num is {}&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会为闭包定义中的每个参数或返回值推断一个具体的类型。如果尝试对同一闭包使用不同类型则就会得到类型错误。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> expression <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x<span class="token punctuation">;</span> <span class="token comment">// 闭包的一个简写形式</span>\n\n<span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token function">expression</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;closure&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token function">expression</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后输出为：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token number">5</span> <span class="token operator">|</span>   <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token function">expression</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token operator">|</span>                <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">-</span> help<span class="token punctuation">:</span> <span class="token keyword">try</span> using a conversion method<span class="token punctuation">:</span> `<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>`\n  <span class="token operator">|</span>                <span class="token operator">|</span>          <span class="token operator">|</span>\n  <span class="token operator">|</span>                <span class="token operator">|</span>          expected `<span class="token class-name">String</span>`<span class="token punctuation">,</span> found integer\n  <span class="token operator">|</span>                arguments to this function are incorrect\n  <span class="token operator">|</span>\nnote<span class="token punctuation">:</span> closure parameter defined here\n <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">21</span>\n  <span class="token operator">|</span>\n<span class="token number">2</span> <span class="token operator">|</span>   <span class="token keyword">let</span> expression <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x<span class="token punctuation">;</span>\n  <span class="token operator">|</span>          \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一次调用闭包时，编译器成功地推断出了这个闭包中 <code>x</code> 的类型以及返回值的类型是 <code>String</code>，同时这些类型被锁进了闭包 <code>expression</code> 中，因此在第二次调用闭包时，就会出现类型错误的问题了。</p><blockquote><p>捕获引用 / 移动所有权</p></blockquote><p>闭包通过三种方式捕获其环境：</p><ul><li>不可变借用</li><li>可变借用</li><li>获取所有权</li></ul><p>这也是函数获取参数的三种方式，闭包会根据函数体中如何使用被捕获的值来决定使用哪种捕获方式。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> closure_arr <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;closure arr: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  \n  <span class="token function">closure_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;After calling closure: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上方代码展示了变量也可以绑定闭包定义，并且之后可以使用变量名和括号调用闭包。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> <span class="token keyword">mut</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;closure arr: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">let</span> <span class="token keyword">mut</span> closure_arr <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token function">closure_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;After calling closure: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>闭包现在捕获了一个可变引用。</p><p>如果我们在闭包调用之前和闭包定义之后，添加一个 <code>println!</code> 宏，看看会发生什么：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> <span class="token keyword">mut</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;closure arr: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">let</span> <span class="token keyword">mut</span> closure_arr <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 闭包的定义</span>\n\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Before calling closure: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token function">closure_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 闭包的调用</span>\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;After calling closure: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用编译器编译后：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token number">5</span> <span class="token operator">|</span>     <span class="token keyword">let</span> <span class="token keyword">mut</span> closure_arr <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token operator">|</span>                           <span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> first borrow occurs due to <span class="token keyword">use</span> of `arr` <span class="token keyword">in</span> closure\n  <span class="token operator">|</span>                           <span class="token operator">|</span>\n  <span class="token operator">|</span>                           mutable borrow occurs here\n<span class="token number">6</span> <span class="token operator">|</span>     <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Before calling closure: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token operator">|</span>                                              <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span> immutable borrow occurs here\n<span class="token number">7</span> <span class="token operator">|</span>     <span class="token function">closure_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token operator">|</span>     <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> mutable borrow later used here\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到了个错误，当 <code>closure_arr</code> 定义时，它捕获了 <code>arr</code> 的可变借用，在闭包调用结束后，可变借用就结束了。因为可变借用存在时，不允许其他借用存在，所以在闭包定义和调用之间不能有不可变借用来进行打印。</p>', 28);
const _hoisted_32 = /* @__PURE__ */ createStaticVNode('<div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>thread<span class="token punctuation">;</span>\n\n<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Before calling closure: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token namespace">thread<span class="token punctuation">::</span></span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;thread: {:?}&quot;</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上方代码中，就通过使用了 <code>move</code> 关键字来强制闭包为线程获取 <code>arr</code> 的所有权，以便在一个新的线程而非主线程中打印 <code>vector</code>。如果主线程维护了 <code>arr</code> 的所有权但却在新线程之前结束并且丢弃了 <code>arr</code> ，则在线程中的不可变借用将失效。</p><blockquote><p>将捕获的值移出闭包 / Fn trait</p></blockquote><p>一旦闭包捕获了定义它环境中的某个值的引用或所有权，闭包体中的代码定义了之后在闭包计算时对引用或值如何操作，那么闭包体就可以做以下任何操作：</p><ul><li>将一个捕获的值移出闭包</li><li>修改捕获的值</li><li>既不移动也不修改值</li></ul><p>闭包捕获和处理环境中的值的方式影响闭包实现的 <code>trait</code> ，<code>trait</code> 是函数和结构体指定它们能用的闭包的类型的方式。取决于闭包如何处理值，闭包会自动地、渐进地实现一个、两个或三个 <code>Fn trait</code> 。</p><ul><li><code>FnOnce</code> ：适用于能够被调用一次的闭包，所有闭包都至少实现了这个 <code>trait</code> ，因为所有闭包都能够被调用。一个会将捕获的值移出闭包体的闭包只实现 <code>FnOnce trait</code> ，因为它只能被调用一次。</li><li><code>FnMut</code>：适用于不会将捕获的值移出闭包体的闭包，但可能会修改被捕获的值。这类闭包可以调用多次。</li><li><code>Fn</code>：适用于既不将被捕获的值移出闭包体也不会修改被捕获的值的闭包，当然也包括不从环境中捕获值的闭包。这类闭包可以调用多次，并且不会改变它们的环境。</li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token comment">// Option&lt;T&gt; 的 unwrap_or_else 方法的实现</span>\n\n<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">unwrap_or_else</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span> \n  <span class="token keyword">where</span>\n  	<span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">FnOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span>\n  <span class="token punctuation">{</span>\n    <span class="token keyword">match</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>\n      <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x<span class="token punctuation">,</span>\n      <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 <code>unwrap_or_else</code> 方法的实现使用了 <code>trait bound</code> ，并且该方法有第二个参数，该参数是一个闭包，因为在 <code>match</code> 表达式的 <code>None</code> 成员中进行了调用。泛型参数 <code>T</code> 是 <code>Option</code> 中 <code>Some</code> 成员的值的类型。泛型 <code>F</code> 的 <code>trait bound</code> 是 <code>FnOnce() -&gt; T</code> ，这意味着闭包必须能够被调用一次，并且没有参数，然后返回一个 <code>T</code>。<code>FnOnce</code> 表示 <code>unwrap_or_else</code> 方法最多调用一次闭包 <code>f</code> ，如果 <code>Option</code> 是 <code>Some</code> ，<code>f</code> 不会被调用，如果 <code>Option</code> 是 <code>None</code>，<code>f</code> 将会被调用一次。</p><h3 id="迭代器" tabindex="-1"><a class="header-anchor" href="#迭代器" aria-hidden="true">#</a> 迭代器</h3>', 10);
const _hoisted_42 = /* @__PURE__ */ createStaticVNode('<div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n	<span class="token keyword">let</span> arr_iter <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码并不会有任何用处，在这里迭代器只是被创建了，但没有选择哪种方式去使用它。一旦迭代器创建之后，可以选择多种方式利用它，比如 <code>for</code> 循环。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n	<span class="token keyword">let</span> arr_iter <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  \n  <span class="token keyword">for</span> i <span class="token keyword">in</span> arr_iter <span class="token punctuation">{</span>\n    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;item: {}&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>for</code> 循环遍历一个数组时，在底层会隐式地创建并接着消费一个迭代器。</p><blockquote><p>Iterator trait 和 next 方法</p></blockquote><p>迭代器都实现了一个叫做 <code>Iterator</code> 的定义于标准库的 <code>trait</code> 。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Iterator</span> <span class="token punctuation">{</span>\n    <span class="token keyword">type</span> <span class="token type-definition class-name">Item</span><span class="token punctuation">;</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Item</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>type Item</code> 和 <code>Self::Item</code> ，这是定义了 <code>trait</code> 的关联类型。这段代码表明实现 <code>Iterator trait</code> 要求同时定义一个 <code>Item</code> 类型，这个 <code>Item</code> 类型被用作 <code>next</code> 方法的返回值类型。</p><p><code>next</code> 是 <code>Iterator</code> 实现者被要求定义的唯一方法，<code>next</code> 一次返回迭代器中的一个项，封装在 <code>Some</code> 中，当迭代器结束时，它返回 <code>None</code>。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token attribute attr-name">#[cfg(test)]</span>\n<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token attribute attr-name">#[test]</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">testing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">let</span> <span class="token keyword">mut</span> arr_iter <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>arr_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>arr_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>arr_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>arr_iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">None</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在迭代器上调用了 <code>next</code> 方法改变了迭代器中用来记录序列位置的状态，换句话说，也就说代码消费了或使用了迭代器，每一个 <code>next</code> 调用都会从迭代器中消费一个项。</p><blockquote><p>消费迭代器的方法</p></blockquote>', 12);
const _hoisted_54 = /* @__PURE__ */ createBaseVNode(
  "code",
  null,
  "Iterator trait",
  -1
  /* HOISTED */
);
const _hoisted_55 = /* @__PURE__ */ createBaseVNode(
  "code",
  null,
  "next",
  -1
  /* HOISTED */
);
const _hoisted_56 = /* @__PURE__ */ createStaticVNode('<div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> arr_iter <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> total <span class="token operator">=</span> arr_iter<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如 <code>sum</code> 方法，这个方法获取迭代器的所有权并反复调用 <code>next</code> 来遍历迭代器，所以会消费迭代器。</p><blockquote><p>产生其他迭代器的方法</p></blockquote>', 3);
const _hoisted_59 = /* @__PURE__ */ createBaseVNode(
  "code",
  null,
  "Iterator trait",
  -1
  /* HOISTED */
);
const _hoisted_60 = /* @__PURE__ */ createStaticVNode('<div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用 <code>map</code> 方法创建一个新的迭代器，接着调用 <code>collect</code> 方法消费新迭代器并创建一个 <code>vector</code>。</p><p>闭包和迭代器是 Rust 受函数式编程所启发的功能，并且它们的实现已经达到了不影响运行时开销的程度了，这正是 Rust 零抽象成本之一。</p>', 3);
function _sfc_render(_ctx, _cache) {
  const _component_font = resolveComponent("font");
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    _hoisted_2,
    _hoisted_3,
    createBaseVNode("p", null, [
      createTextVNode("Rust 的闭包（closure）是可以"),
      createVNode(_component_font, { color: "red" }, {
        default: withCtx(() => [
          createTextVNode("保存在一个变量中或作为参数传递给其他函数的匿名函数")
        ]),
        _: 1
        /* STABLE */
      }),
      createTextVNode("。")
    ]),
    _hoisted_4,
    createVNode(_component_font, { color: "red" }, {
      default: withCtx(() => [
        createTextVNode("闭包体不严格需要所有权，如果希望闭包强制获取它用到的环境中值的所有权，可以在参数列表前面使用 `move` 关键字")
      ]),
      _: 1
      /* STABLE */
    }),
    createTextVNode("。"),
    _hoisted_32,
    createVNode(_component_font, { color: "red" }, {
      default: withCtx(() => [
        createTextVNode("迭代器是 Rust 零成本抽象（zero-cost）之一，这种现象意味着抽象并不会引入运行时开销")
      ]),
      _: 1
      /* STABLE */
    }),
    createTextVNode("。"),
    createBaseVNode("p", null, [
      createTextVNode("迭代器允许你对一个序列的项进行某种处理，"),
      createVNode(_component_font, { color: "red" }, {
        default: withCtx(() => [
          createTextVNode("负责遍历序列中的每一项和决定序列何时结束的逻辑")
        ]),
        _: 1
        /* STABLE */
      }),
      createTextVNode("，可以类比 JS 中的迭代器。")
    ]),
    createBaseVNode("p", null, [
      createTextVNode("在 Rust 中，"),
      createVNode(_component_font, { color: "red" }, {
        default: withCtx(() => [
          createTextVNode("迭代器是惰性的")
        ]),
        _: 1
        /* STABLE */
      }),
      createTextVNode("，这意味着在调用方法使用迭代器之前它都不会有效果，也就是需要一把钥匙来触发迭代器，它才能生效。")
    ]),
    _hoisted_42,
    createBaseVNode("p", null, [
      _hoisted_54,
      createTextVNode(" 有一系列不同的由标准库提供默认实现的方法，"),
      createVNode(_component_font, { color: "red" }, {
        default: withCtx(() => [
          createTextVNode("调用 "),
          _hoisted_55,
          createTextVNode(" 方法的方法被称为消费适配器，因为调用它们会消耗迭代器。")
        ]),
        _: 1
        /* STABLE */
      })
    ]),
    _hoisted_56,
    createBaseVNode("p", null, [
      _hoisted_59,
      createTextVNode(" 定义了另一类方法，被称为迭代器适配器，"),
      createVNode(_component_font, { color: "red" }, {
        default: withCtx(() => [
          createTextVNode("它允许我们将当前迭代器变为不同类型的迭代器。")
        ]),
        _: 1
        /* STABLE */
      }),
      createTextVNode("可以链式调用多个迭代器适配器，不过由于所有迭代器都是惰性的，因此需要调用一个消费适配器来获取迭代器适配器调用的结果。")
    ]),
    _hoisted_60
  ]);
}
const rustIteratorClosure_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "rust-iterator-closure.html.vue"]]);
export {
  rustIteratorClosure_html as default
};
