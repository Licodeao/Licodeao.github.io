import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="前瞻" tabindex="-1"><a class="header-anchor" href="#前瞻" aria-hidden="true">#</a> 前瞻</h2><p>与上篇文章一样，属于探索类别。</p><p>今天结束了后台项目的部署上线，过程还算顺利，但在配置Nginx时出现了一点点问题，事后总结应该归属于团队合作没有配合好。由于自己之前也部署过项目上线，所以自认为在配置Nginx这个环节不会出差错，谁曾想，啪啪打脸...</p><p>所以，还是鼓足勇气准备决定开个Nginx专栏，来巩固与拓展自己的知识面与深度，嗯，就这么愉快的决定了！</p><p>至此，目前有2个专栏了：</p><ul><li>Google V8引擎</li><li>Nginx</li></ul><p>最近关于招新的技术准备已落下帷幕</p><p>噢对了，今后除了部门工作需要及其他情况外，我绝不会在个人项目开发中再使用uniapp去写微信小程序了（发誓！！！）</p><p>后续招新只剩维护及后续版本更新迭代了</p><h3 id="tag" tabindex="-1"><a class="header-anchor" href="#tag" aria-hidden="true">#</a> Tag</h3><ul><li>关于V8专栏的第二篇，预计在国庆放假前一周周末(9.23-9.25)出</li><li>Nginx专栏的第一篇会在9.23之前出</li></ul><h2 id="正文" tabindex="-1"><a class="header-anchor" href="#正文" aria-hidden="true">#</a> 正文</h2><blockquote><p>先来个DOM的继承图</p></blockquote><p><img src="https://typora-licodeao.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220918235211566.png" alt="image-20220918235211566"></p><p>可以从图中发现，<strong>EventTarget是DOM的父类</strong>，<strong>所有的节点/元素都继承自EventTarget。</strong></p><p>EventTarget是一个<strong>DOM接口</strong>，可以<strong>添加、删除、派发事件</strong>。因此，EventTarget可以实现类似事件总线的效果。</p><h3 id="eventtarget常见的方法" tabindex="-1"><a class="header-anchor" href="#eventtarget常见的方法" aria-hidden="true">#</a> EventTarget常见的方法</h3><ul><li><p>addEventListener</p><ul><li><p>相信这个方法已经很熟悉了，用于<strong>添加、注册事件</strong>。</p></li><li><p>注册事件有两种方式</p><ul><li><p>传统方法：通过on开头的事件来注册</p><ul><li>该方法具有<strong>唯一性</strong>：同一个元素同一个事件只能设置同一个事件处理函数</li></ul></li><li><p>非传统方法：通过addEventListener来注册事件</p><ul><li><p>该方法的特点：同一个元素同一个事件<strong>可以设置多个监听器</strong></p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 将指定的监听器注册到eventTarget对象上，当该对象触发指定的事件时，就会执行对应的事件处理函数</span>\neventTarget<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> listener<span class="token punctuation">[</span><span class="token punctuation">,</span> useCapture<span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>type</th><th>事件类型，如click、mouseover等，注意不能带on</th></tr></thead><tbody><tr><td>listener</td><td>事件处理函数，指定事件发生时，就会触发该函数</td></tr><tr><td>useCapture</td><td>是否捕获(true为事件捕获)，<strong>默认为false(也就是事件冒泡)</strong></td></tr></tbody></table></li></ul></li></ul></li></ul></li><li><p>removeEventListener</p><ul><li><strong>移除某个事件类型及事件处理函数有</strong>两种方法 <ul><li><code>eventTarget.onclick = null</code></li><li><code>eventTarget.addEventListener(type, listener[, useCapture])</code></li></ul></li></ul></li><li><p>dispatchEvent(派发事件)</p></li></ul><blockquote><p>因为需要演示例子，所以先说个结论：</p><p>实际上，<strong>window也继承自EventTarget</strong>，所以在演示时通过window调用父类EventTarget的dispatchEvent方法</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 派发自定义事件</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> window<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">&quot;licodeao&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span> <span class="token comment">// 3秒后，派发licodeao事件</span>\n\n<span class="token comment">// 监听自定义事件</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;licodeao&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;监听到licodeao事件啦~&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>虽然，在开发中并不会用此方法，但对理解事件总线应该会有帮助吧</p><p>至少了解到了一点新奇的玩意儿~</p>', 23);
const _hoisted_24 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_24);
}
const How_to_customize_event_in_EventTarget_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "How to customize event in EventTarget.html.vue"]]);
export {
  How_to_customize_event_in_EventTarget_html as default
};
