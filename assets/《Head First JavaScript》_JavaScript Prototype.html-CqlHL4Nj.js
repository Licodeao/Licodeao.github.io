import { _ as _export_sfc, o as openBlock, c as createElementBlock, f as createStaticVNode } from "./app-5wU-U7Lk.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h2 id="首先来谈一谈读后感" tabindex="-1"><a class="header-anchor" href="#首先来谈一谈读后感" aria-hidden="true">#</a> 首先来谈一谈读后感</h2><p>这本书大约有650多页，刨去其中的练习及其答案页，也应该有500多页，所以你可以想想里面有着多少关于JavaScript的知识。有人可能看到这么厚的书，就已经退避三舍、望而却步了。其实，不用害怕，如果你拿这本书来入门JavaScript，我觉得非常好。其实按道理来说，不管哪本书，你只要认真耐着性子去看完读完，相信都会有一番收获的。当然关于这本书，最让我觉得异于其他编程语言书的是，里面充斥着有趣的图画以及作者幽默风趣的描述。给我的感觉是，当遇到一个比较难理解的概念时，作者不会像那些古板的人一样，直接抛出概念让你自己去理解，而是以朋友的角度来和你面对面说一样。因而，我读完这本书，里面的任何概念我都能够理清，并且在其他任何代码中看到它时，我都能认出它。所以，这本书总的来说就是风趣幽默的同时又给你认真地讲解概念，（也可能是由于国外作者的缘故，让这本书形成了这种叙述风格），好书当然得重读一遍，不过价格确实有点小贵，单本129元，不过我当时在某东遇上活动买了一堆书，就显得这本书单价就很便宜了，值得推荐。</p><hr><h2 id="对象模型" tabindex="-1"><a class="header-anchor" href="#对象模型" aria-hidden="true">#</a> 对象模型</h2><p>由于我之前学过Java，就在学JavaScript之前了解过一点对象的概念，但这并不妨碍我去理解JS中的对象，反而是一种帮助。学过Java的都知道，创建对象需要通过类，<strong>但JavaScript根本就没有类，而是通过从其他对象那里继承行为和属性，这被称为原型式继承，也叫基于原型的继承。</strong></p><hr><p>在没有学习过原型继承之前，我们都是通过<strong>对象字面量</strong>来创建一个对象，比如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> fido <span class="token operator">=</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Fido&quot;</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">breed</span><span class="token operator">:</span> <span class="token string">&quot;Mixed&quot;</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">5</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过对象字面量创建对象，则当需要创建多个对象时，你需要在对象里面，为它添加很多属性和方法，而且某些属性和之前完全相同，你只是在<strong>不停的重用它</strong>，而且代码量大大增加。所以，还有一种创建对象的方法，是通过<strong>对象构造函数</strong>来创建的。它能帮助我们<strong>创建大量的对象</strong>，且创建不同对象时，不需要重用其属性，例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>breed<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n         <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n         <span class="token keyword">this</span><span class="token punctuation">.</span>breed <span class="token operator">=</span> breed<span class="token punctuation">;</span>\n         <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> fido <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">&quot;Fido&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Mixed&quot;</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> spot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">&quot;Spot&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Chihuahua&quot;</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们定义了一个叫Dog的构造函数，它里面包含name,breed,age三个属性。因此我们创建不同的小狗对象时，只需要为每个不同的小狗对象传入不同的实参即可。</p><hr><h2 id="那么-构造函数的工作原理又是什么" tabindex="-1"><a class="header-anchor" href="#那么-构造函数的工作原理又是什么" aria-hidden="true">#</a> 那么，构造函数的工作原理又是什么？</h2><p>说说其<strong>工作原理</strong>：</p><p>通过观看上面的代码，我们可以看到当创建对象时，都要写一个new运算符来调用构造函数。那么new运算符都做了什么呢？我们的视线都暂且停留在赋值运算的右边：1、<strong>new运算符创建了一个新的空对象</strong>。2、<strong>new设置this,使其指向刚刚创建的新对象</strong>。3、<strong>调用构造函数Dog，将三个实参传递给Dog的三个形参</strong>。4、<strong>构造函数Dog给新创建的this指向的对象的属性赋值</strong>。5、<strong>Dog函数执行完后，new返回this，指向新创建的对象的引用</strong>。这里需要注意的是，<strong>它会为你自动地返回this，你无需在代码中显示地返回。返回this后，我们将其赋值给变量，存储在变量中。</strong></p><p>能为对象添加属性和方法，在构造函数中也一样能干。</p><p>对象在<code>JS</code>中是一个<strong>动态的结构</strong>，无论对象包含哪些属性和方法，<strong>其类型都是Object</strong>。<strong>当用new运算符调用一个构造函数时，都将创建一个新的对象实例。由同一个构造函数创建的对象都是相同类型的对象。</strong></p><hr><h2 id="当我们用构造函数创建对象时-如果出现了包含的形参过多怎么办" tabindex="-1"><a class="header-anchor" href="#当我们用构造函数创建对象时-如果出现了包含的形参过多怎么办" aria-hidden="true">#</a> <strong>当我们用构造函数创建对象时，如果出现了包含的形参过多怎么办？</strong></h2><p>针对这种情况，我们就要将对象字面量与对象构造函数相结合使用了，显然极端地使用某一种方式在某些问题上，根本行不通。例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token parameter">make<span class="token punctuation">,</span>model<span class="token punctuation">,</span>year<span class="token punctuation">,</span>color<span class="token punctuation">,</span>passengers<span class="token punctuation">,</span>convertible<span class="token punctuation">,</span>mileage</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n               <span class="token operator">...</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> cadi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">&quot;GM&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Cadillac&quot;</span><span class="token punctuation">,</span><span class="token number">1955</span><span class="token punctuation">,</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token number">12892</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子能看出，使用构造函数创建对象时，需要传入的实参实在是过多了。如何解决这种问题？<strong>我们将所有实参放到一个对象字面量中，再将这个对象字面量传给函数。这就像通过一个容器来传递所有的值</strong>。例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> cadiparam <span class="token operator">=</span> <span class="token punctuation">{</span>\n       <span class="token literal-property property">make</span><span class="token operator">:</span> <span class="token string">&quot;GM&quot;</span><span class="token punctuation">,</span>\n       <span class="token literal-property property">model</span><span class="token operator">:</span> <span class="token string">&quot;Cadillac&quot;</span><span class="token punctuation">,</span>\n       <span class="token literal-property property">year</span><span class="token operator">:</span> <span class="token number">1955</span><span class="token punctuation">,</span>\n       <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span>\n       <span class="token literal-property property">passengers</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>\n       <span class="token literal-property property">convertible</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n       <span class="token literal-property property">mileage</span><span class="token operator">:</span> <span class="token number">12892</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> cadi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span>cadiparam<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好像对于代码量来说，好像并没有啥改变。但对于在给构造函数传入实参时，能够避免出现不必要的错误。</p><hr><h2 id="好了-扯了那么久-又回到原型了" tabindex="-1"><a class="header-anchor" href="#好了-扯了那么久-又回到原型了" aria-hidden="true">#</a> 好了，扯了那么久，又回到原型了</h2><p>当我们用上述的构造函数创建对象时，<strong>每个对象都有自己的副本</strong>，当在其中添加方法时，由于对象都有其副本，所以<strong>在运行阶段时，每个对象都将创建一组新的方法</strong>，<strong>这会占用计算机的资源，并且影响应用程序的性能</strong>。</p><p>我们可以通过<strong>扩展其他对象来创建对象，也就是通过原型对象来创建对象</strong>。<strong>由原型对象创建而成的对象，它继承了原型对象的属性和方法</strong>，我们在这里可以将原型对象想象成父类，将由原型对象创建而成的对象想象成子类，那么子类就自然而然地继承了父类的所有方法及属性。<strong>在继承了原型的对象中，只需加入新的属性和方法，原型有的属性和方法不用重写，因为它继承了这些属性和方法。</strong></p><hr><h2 id="继承的工作原理又是什么" tabindex="-1"><a class="header-anchor" href="#继承的工作原理又是什么" aria-hidden="true">#</a> 继承的工作原理又是什么？</h2><p>当对象实例调用了自己本身没有的属性和方法时，JavaScript如果在对象中找不到，那么将在原型中查找它。也就是说，查找的顺序一定是：<strong>先在对象实例中查找——</strong>&gt;<strong>对象实例中找不到，就向继承链上方查找，也就是在原型中查找</strong>。继承原型并不意味着必须与它相同，当然可以重写原型的属性和方法。</p><h2 id="如何创建一个原型" tabindex="-1"><a class="header-anchor" href="#如何创建一个原型" aria-hidden="true">#</a> 如何创建一个原型？</h2><p><strong>构造函数中有一个属性prototype，该属性是一个指向原型的引用。</strong></p><h2 id="如何设置原型" tabindex="-1"><a class="header-anchor" href="#如何设置原型" aria-hidden="true">#</a> 如何设置原型？</h2><p>通过构造函数的一个属性prototype来访问原型对象。<strong>大致的顺序为：先创建一个构造函数，再获取其属性prototype，再为原型添加属性和方法，依次来设置原型。例如：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>breed<span class="token punctuation">,</span>weight</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>breed <span class="token operator">=</span> breed<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">&quot;Canine&quot;</span><span class="token punctuation">;</span>\n<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bark</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">&gt;</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n               console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&quot; says woof!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n               console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&quot; says yip!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上方代码中，我们为Dog原型中，新增了属性species和方法bark。<strong>在任何情况下，this都指向原始对象，即方法被调用的对象。原型是动态的</strong>，也就是说，当我们在原型中新增了一个属性和方法时，继承该原型的任何对象都能使用这个方法和属性。</p><h2 id="如何判断使用的属性是包含在实例中还是原型中" tabindex="-1"><a class="header-anchor" href="#如何判断使用的属性是包含在实例中还是原型中" aria-hidden="true">#</a> 如何判断使用的属性是包含在实例中还是原型中？</h2><p><strong>每个对象</strong>都有一个方法<strong>hasOwnProperty</strong>，<strong>如果属性是在对象实例中定义的，则返回true</strong>，如果是在原型中定义的，则返回false。<strong>其参数为一个字符串</strong>。</p><h2 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h2><p>对象不仅可以继承一个原型的属性，还可以<strong>继承一个原型链</strong>。原型链中的继承原理，和上面说到的继承原理是一样的，<strong>先在对象实例中查找，找不到则沿着原型链向上查找</strong>。</p><h2 id="那么如何继承一个原型对象呢" tabindex="-1"><a class="header-anchor" href="#那么如何继承一个原型对象呢" aria-hidden="true">#</a> 那么如何继承一个原型对象呢？</h2><p>依然要用到new运算符，例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>breed<span class="token punctuation">,</span>weight</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>breed <span class="token operator">=</span> breed<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">ShowDog</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>breed<span class="token punctuation">,</span>weight</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>breed <span class="token operator">=</span> breed<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">ShowDog</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依据上方的代码 ，我们成功地创建了一个继承原型对象的对象，顺序依然是<strong>创建该对象的构造函数，通过函数名调用其属性prototype，然后将其属性prototype设置为一个新的对象实例。新创建的原型对象，依然是原来原型的一个对象实例</strong>。新的原型创建成功后，我们就可以给它添加新的属性和方法了。</p><p>值得注意的是，所有对象都是从Object派生而来，它是对象的始祖，实际上Object也有原型，其原型为<code>Object.prototype</code>。</p><h2 id="结束语" tabindex="-1"><a class="header-anchor" href="#结束语" aria-hidden="true">#</a> 结束语</h2><p>《Head First JavaScript》这本书就此结束啦，在JavaScript中，一切几乎皆是对象，学习永远没有解脱的时候。</p>', 48);
const _hoisted_49 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_49);
}
const _Head_First_JavaScript__JavaScript_Prototype_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "《Head First JavaScript》_JavaScript Prototype.html.vue"]]);
export {
  _Head_First_JavaScript__JavaScript_Prototype_html as default
};
